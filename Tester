[
	{
		"question": "Kỹ thuật được áp dụng để kiểm tra khả năng sử dụng là?",
		"right": "Hộp đen"
	},
	{
		"question": "{{Thẩm tra || Verification}} là quá trình đánh giá phần mềm có đáp ứng các yêu cầu được thiết lập trong giai đoạn trước hay không.",
		"right": null
	},
	{
		"question": "{{Xác nhận || Validation}} là quá trình đánh giá phần mềm có đảm bảo tuân thủ với mục đích sử dụng hay không.",
		"right": null
	},
	{
		"question": "Bằng cách thu thập ________ trong quá trình kiểm thử phần mềm, có thể phát triển các hướng dẫn có ý nghĩa để tạm dừng quá trình kiểm thử.",
		"right": "Số liệu"
	},
	{
		"question": "Bắt đầu kiểm thử sớm hay muộn tốt hơn?",
		"right": "Sớm"
	},
	{
		"question": "Các ca kiểm thử trong phương pháp kiểm thử hộp trắng được sinh ra từ đâu?",
		"right": "Mã nguồn."
	},
	{
		"question": "Các dev và tester cùng nhau hợp tác để tìm ra các nguy cơ là ở mức độ (level) nào?",
		"right": "Mức độ 3."
	},
	{
		"question": "Các hoạt động kiểm thử phần mềm nên bắt đầu khi nào?",
		"right": "Càng sớm càng tốt trong vòng đời phát triển."
	},
	{
		"question": "Chất lượng của một phần mềm được thể hiện bằng những đặc trưng phù hợp với {{đặc tả}} của nó.",
		"right": null
	},
	{
		"question": "Chi phí sửa lỗi ít nhất khi chú trọng kiểm thử từ giao đoạn nào?",
		"right": "Giai đoạn phân tích thiết kế yêu cầu."
	},
	{
		"question": "Chọn đáp án không phải là một hành vi của phần mềm?",
		"right": "Tạo cấu trúc"
	},
	{
		"question": "Chúng ta {{không thể}} giảm lỗi của sản phẩm phần mềm về mức 0.",
		"right": null
	},
	{
		"question": "Danh sách các mục để kiểm thử được gọi là",
		"right": "Danh sách kiểm tra (Checklist)"
	},
	{
		"question": "Đâu không là lý do cho việc kiểm thử phần mềm?",
		"right": "Để kiểm tra hiệu suất của các nhà phát triển"
	},
	{
		"question": "Đâu không phải là một sai lầm về dữ liệu?",
		"right": "Thuật toán sai."
	},
	{
		"question": "Đâu không phải là một sai lầm về giao diện?",
		"right": "Hàm đi kèm sai"
	},
	{
		"question": "Đâu không phải là một sai lầm về logic khi thực hiện một bài kiểm thử?",
		"right": "Kết quả tính toán đúng nhưng không đúng thời điểm"
	},
	{
		"question": "Đâu không phải là tiêu chí đánh giá chất lượng phần mềm?",
		"right": "Tính cụ thể hóa"
	},
	{
		"question": "Đâu không phải lý do kiểm thử với danh sách kiểm tra (checklist) không hiệu quả",
		"right": "Nó theo dõi những gì đã được thực hiện"
	},
	{
		"question": "Điều nào sau đây là đúng đối với Khiếm khuyết Thảm khốc?",
		"right": "Che giấu các khuyết tật khác."
	},
	{
		"question": "Điều nào sau đây là mục tiêu quan trọng của các hoạt động kiểm thử trong vòng tròn phát triển phần mềm?",
		"right": "Gỡ lỗi"
	},
	{
		"question": "Định nghĩa {{gỡ lỗi}} là kiểm tra xem lỗi đã được báo cáo trước đó đã được sửa.",
		"right": null
	},
	{
		"question": "Định nghĩa của gỡ lỗi là gì?",
		"right": "Kiểm tra xem lỗi đã được báo cáo trước đó đã được sửa."
	},
	{
		"question": "Định nghĩa của xác minh (verification)?",
		"right": "Là quá trình xác định xem các sản phẩm của một giai đoạn nhất định của quá trình phát triển phần mềm có đáp ứng được các yêu cầu được thiết lập ở các pha trước không."
	},
	{
		"question": "Đoán lỗi (Error) là:",
		"right": "Kỹ thuật quản lý dữ liệu kiểm thử."
	},
	{
		"question": "Hoạt động nào dưới đây không là Kiểm định (Verification)?",
		"right": "Kiểm thử hệ thống"
	},
	{
		"question": "Hoạt động nào dưới đây là Thẩm định (Validation)?",
		"right": "Duyệt mã nguồn (code review)"
	},
	{
		"question": "Khi nào thì quá trình kiểm thử kết thúc?",
		"right": "Khi chất lượng phần mềm đã đạt được tiêu chí."
	},
	{
		"question": "Khiếm khuyết (fault) và các thất bại (failure) đều có thể được gọi chung là {{lỗi}}.",
		"right": null
	},
	{
		"question": "Khóa học này tập trung vào kiếm thức kiểm thử cho {{người lập trình viên}}.",
		"right": null
	},
	{
		"question": "Kiểm chứng (verification) là quá trình để đảm bảo rằng một sản phẩm phần mềm thỏa mãn?",
		"right": "Đặc tả của nó"
	},
	{
		"question": "Kiểm thử {{hộp trắng}} là kỹ thuật để kiểm tra khả năng sử dụng.",
		"right": null
	},
	{
		"question": "Kiểm thử bậc {{0}} được xem là tương đương với việc gỡ lỗi (debugging).",
		"right": null
	},
	{
		"question": "Kiểm thử bậc nào được xem là tương đương với việc gỡ lỗi (debugging)?",
		"right": "Bậc 0."
	},
	{
		"question": "Kiểm thử giúp __________ của sản phẩm bằng cách tìm ra các khuyết tật trong sản phẩm.",
		"right": "Đo lường chất lượng"
	},
	{
		"question": "Kiểm thử giúp {{đo lường chất lượng}} của sản phẩm bằng cách tìm ra các khuyết tật trong sản phẩm.",
		"right": null
	},
	{
		"question": "Kiểm thử mức {{0}} không phân biệt được hành vi không chính xác của chương trình và lỗi trong chương trình.",
		"right": null
	},
	{
		"question": "Kiểm thử mức {{2}} đặt lập trình viên và kiểm thử viên vào trạng thái đối đầu.",
		"right": null
	},
	{
		"question": "Kiểm tra hệ thống là một kiểm thử hộp {{đen}}.",
		"right": null
	},
	{
		"question": "Loại kiểm thử nào dựa trên quan niệm rằng bất kì chương trình nào cũng là một hàm ánh xạ từ miền dữ liệu đầu vào đến miền dữ liệu đầu ra của nó?",
		"right": "Kiểm thử chức năng"
	},
	{
		"question": "Lỗi do lỗi tĩnh trong chương trình tạo nên, gây ra kết quả chạy không đúng với ước tính được gọi là gì?",
		"right": "Software error."
	},
	{
		"question": "Lỗi phần mềm (Software errors) là gì?",
		"right": "Là lỗi do lỗi tĩnh trong chương trình tạo nên, gây ra kết quả chạy không đúng với ước tính."
	},
	{
		"question": "Lỗi phần mềm (Software fault) xuất hiện khi nào?",
		"right": "Lúc triển khai dự án phần mềm."
	},
	{
		"question": "Lỗi tồn tại trong phần mềm càng lâu thì ___.",
		"right": "Tất cả các đáp án trên."
	},
	{
		"question": "Mối quan hệ giữa kiểm thử (testing) và đảm bảo chất lượng (quality assurance - QA) là gì?",
		"right": "Kiểm thử là một phần của quá trình bảo đảm chất lượng hoàn chỉnh"
	},
	{
		"question": "Một khái niệm quan trọng của đảm bảo chất lượng là tất cả các sản phẩm?",
		"right": "Được kiểm tra kỹ lưỡng \\/ xem xét trước khi giao cho khách hàng"
	},
	{
		"question": "Một lỗi (error) là?",
		"right": "Một hành động của con người mà tạo ra một kết quả không chính xác"
	},
	{
		"question": "Mức độ kiểm thử nào sau đây thuộc quá trình xác nhận (Validation)?",
		"right": "Kiểm thử chấp nhận (Acceptance Testing)."
	},
	{
		"question": "Mục tiêu của người kiểm thử là {{loại bỏ}} lỗi càng sớm càng tốt",
		"right": null
	},
	{
		"question": "Ở mức độ (level) nào thì mọi người bắt đầu nhận ra rằng thử nghiệm (testing) chỉ là 1 cách để cái tiến được chương trình?",
		"right": "Mức độ 4."
	},
	{
		"question": "Pha nào phát hiện lỗi trước trong số các pha sau?",
		"right": "Kiểm định (Verification)"
	},
	{
		"question": "Phát biểu nào sau đây là đúng về mô hình chữ V?",
		"right": "Nó bao gồm việc kiểm định và thẩm định"
	},
	{
		"question": "Quá trình kiểm thử dựa trên phân tích động không tồn tại bước nào sau đây?",
		"right": "Nghiên cứu khả thi"
	},
	{
		"question": "Tại sao phải bắt đầu kiểm thử sớm?",
		"right": "Vì bắt đầu kiểm thử muộn sẽ tiêu tốn nhiều nguồn lực."
	},
	{
		"question": "Thẩm định (validation) là quá trình để đảm bảo rằng sản phẩm đáp ứng được yêu cầu của?",
		"right": "Khách hàng"
	},
	{
		"question": "Thẩm định (validation) là quá trình kiểm tra xem sản phẩm theo đúng với thử nào sau đây?",
		"right": "Yêu cầu của khách hàng."
	},
	{
		"question": "Thế nào là kiểm thử mức độ (level) 0?",
		"right": "-"
	},
	{
		"question": "Trong các mức kiểm thử của Beizer, hiện nay đa số các công ty phần mềm đang dừng kiểm thử ở mức thứ {{2}}.",
		"right": null
	},
	{
		"question": "Trong các quy trình phát triển phần mềm, đặc biệt là quy trình Agile, lập trình viên cần có kỹ năng kiểm thử tối thiểu ở mức độ nào để sản phẩm có chất lượng tốt nhất?",
		"right": "Kiểm thử đơn vị (Unit Testing)."
	},
	{
		"question": "Trong kiểm thử bậc {{3}}, kiểm thử viên làm việc với lập trình viên để giảm thiểu rủi ro.",
		"right": null
	},
	{
		"question": "Trong kiểm thử bậc 3, {{kiểm thử viên}} làm việc cùng nhà phát triển phần mềm để giảm thiểu rủi ro.",
		"right": null
	},
	{
		"question": "Trong kiểm thử bậc 3, người kiểm thử làm việc cùng ai để giảm thiểu rủi ro?",
		"right": "Người phát triển phần mềm."
	},
	{
		"question": "Trong quá trình phát triển phần mềm, thường thì đâu là giai đoạn tiêu tốn nhiều thời gian và chi phí nhất?",
		"right": "Kiểm thử."
	},
	{
		"question": "Trường hợp nào là ví dụ cho xác minh (Verification)?",
		"right": "Các bài kiểm tra đơn vị ánh xạ các yêu cầu với hành vi của lớp."
	},
	{
		"question": "Vấn đề nào sau đây phải được giải quyết nếu một chiến lược kiểm thử phần mềm thành công được thực hiện?",
		"right": "Tất cả những điều đã đề cập"
	},
	{
		"question": "Việc phân tích nào được thực hiện dựa trên việc khảo sát các tài liệu được xây dựng trong quá trình phát triển sản phẩm phần mềm?",
		"right": "Phân tích tĩnh"
	},
	{
		"question": "Việc tăng chất lượng của phần mềm, bằng các phương pháp phát triển tốt hơn, sẽ ảnh hưởng đến thời gian cần thiết để kiểm thử (các giai đoạn kiểm thử) như thế nào?",
		"right": "Giảm thời gian kiểm thử."
	},
	{
		"question": "Xác minh (Verification) là quá trình:",
		"right": "Kiểm tra xem hệ thống có đang được phát triển theo đúng như thiết kế ban đầu."
	},
	{
		"question": "Các khiếm khuyết (Faults) thường được phát hiện nhiều nhất ở pha nào?",
		"right": "Kiểm thử hệ thống."
	},
	{
		"question": "Chi phí sửa chữa các khiếm khuyết (Faults) được phát hiện sẽ nhiều nhất ở pha nào?",
		"right": "Triển khai."
	},
	{
		"question": "Có ý kiến cho rằng: \"Rủi ro (risk) khi sử dụng phần mềm là luôn tồn tại, bất kể dù rủi ro lớn gây hỏng phần mềm đến rủi ro nhỏ gây trải nghiệm thất thường\". Dựa vào bậc 3 của thang kiểm thử Beizer, ý kiến trên có đúng không?",
		"right": "Ý kiến trên đúng về rủi ro khi sử dụng phần mềm."
	},
	{
		"question": "Lỗi do sự khác biệt giữa kết quả thực thi chương trình với kết quả mong đợi của một thành phần, hệ thống hoặc dịch vụ nào đó gọi là lỗi gì?",
		"right": "Thất bại (Failure)"
	},
	{
		"question": "Lỗi sai (fault) được người dùng tìm thấy là do ý nào sau đây?",
		"right": "Phần mềm chưa đáp ứng được và kiểm thử chưa tìm ra hết lỗi."
	},
	{
		"question": "Một lỗi được phát hiện càng muộn, thì việc sửa chữa càng tốn kém. Tại sao?",
		"right": "Lỗi đã được tích hợp vào nhiều tài liệu, mã,..."
	},
	{
		"question": "Những gì thường được coi là phụ trợ cho bước mã hóa?",
		"right": "Kiểm tra đơn vị"
	},
	{
		"question": "Chi phí dành cho việc kiểm thử là lớn nhất ở giai đoạn nào?",
		"right": "Giai đoạn sau khi triển khai."
	},
	{
		"question": "Đặc điểm nào sau đây không phải là đặc điểm chung của kiểm thử phần mềm?",
		"right": "Các kỹ thuật kiểm tra khác nhau phù hợp tại các thời điểm khác nhau."
	},
	{
		"question": "Đâu không phải là mục đích chung của kiểm thử?",
		"right": "Đánh giá trình độ của đội ngũ phát triển"
	},
	{
		"question": "Đâu không phải là mục đích của việc kiểm thử?",
		"right": "Đa dạng hóa công dụng của phần mềm."
	},
	{
		"question": "Điều nào sau đây không phải là trường hợp kiểm thử hồi quy?",
		"right": "Các thành phần cấp thấp được kết hợp thành các cụm thực hiện một chức năng con phần mềm cụ thể"
	},
	{
		"question": "Kiểm thử nên được thực hiện lúc nào?",
		"right": "Càng sớm càng tốt trong vòng đời phát triển phần mềm"
	},
	{
		"question": "Mục đích của kiểm thử cấp độ 3 là gì?",
		"right": "Giảm thiểu rủi ro"
	},
	{
		"question": "Nâng cao chất lượng trở thành kỷ luật từ trong tinh thần là đặc điểm của mức độ trưởng thành nào trong kiểm thử?",
		"right": "Mức độ 4."
	},
	{
		"question": "Ở cấp độ thử nghiệm nào, trọng tâm là mức độ sử dụng của khách hàng?",
		"right": "Cả Alpha và Beta"
	},
	{
		"question": "Trường hợp nào khả thi nhất nếu đoạn chương trình hoàn thành hết tất cả các ca kiểm thử và không sai m���t ca nào?",
		"right": "Chương trình đã hoàn thiện hoặc các ca kiểm thử đó không phát hiện được lỗi."
	},
	{
		"question": "Đâu không phải là một hoạt động về kiểm thử trong giai đoạn triển khai hệ thống (System Deployment)?",
		"right": "Kiểm thử đơn vị (Unit Testing)."
	},
	{
		"question": "Đâu là một hoạt động về kiểm thử trong giai đoạn vận hành và bảo trì (Operation and Maintenance)?",
		"right": "Kiểm thử quy hồi (Regression Testing)"
	},
	{
		"question": "Lập kế hoạch kiểm thử để làm gì?",
		"right": "Để chỉ định và mô tả các loại kiểm thử sẽ được triển khai và thực hiện."
	},
	{
		"question": "Cơ sở kiểm thử (Test Basis) của kiểm thử thành phần không bao gồm ý_x001D_ nào trong các ý dưới đây?",
		"right": "Biểu đồ tuần tự (Sequence diagrams)"
	},
	{
		"question": "Cơ sở kiểm thử (Test Basis) của kiểm thử tích hợp không bao gồm ý_x001D_ nào trong các ý dưới đây?",
		"right": "Tài liệu đặc tả phần mềm (SRS)"
	},
	{
		"question": "Đâu là một đặc tính tốt của bất kì mô hình kiểm thử nào?",
		"right": "Mỗi giai đoạn kiểm thử đều có mục tiêu cụ thể"
	},
	{
		"question": "Điều nào sau đây là một hình thức kiểm tra chức năng?",
		"right": "Phân tích giá trị biên"
	},
	{
		"question": "Điều nào sau đây là thử nghiệm phi chức năng?",
		"right": "Kiểm thử hiệu năng"
	},
	{
		"question": "Kiểm tra hệ thống phi chức năng bao gồm?",
		"right": "Kiểm thử để xem nơi hệ thống không hoạt động đúng chức năng."
	},
	{
		"question": "Mô hình “V” là gì?",
		"right": "Mức độ kiểm tra"
	},
	{
		"question": "Một tập các yếu tố đầu vào, bao gồm điều kiện ràng buộc và kết quả mong đợi được gọi là gì?",
		"right": "Trường hợp kiểm thử."
	},
	{
		"question": "Nếu một ứng dụng cho phép thực thi nhiều phiên bản của chính nó, chúng sẽ xuất hiện trên màn hình dưới dạng các cửa sổ riêng biệt được gọi là",
		"right": "Cửa sổ"
	},
	{
		"question": "Phương pháp kiểm thử giá trị biên được thường xuyên sử dụng trong loại kiểm thử nào sau đây?",
		"right": "Kiểm thử chức năng"
	},
	{
		"question": "Phương pháp kiểm thử mà trong đó các ca kiểm thử được sinh ra từ mô hình đặc tả hành vi của hệ thống đang được kiểm thử là?",
		"right": "Kiểm thử dựa trên mô hình"
	},
	{
		"question": "Sự khác nhau giữa kiểm thử hộp đen và kiểm thử hộp trắng là gì?",
		"right": "Hộp đen là chức năng, hộp trắng là cấu trúc."
	},
	{
		"question": "Thử nghiệm Sanity là gì?",
		"right": "Mức độ thực thi kiểm tra"
	},
	{
		"question": "Trong kĩ thuật {{kiểm thử tĩnh}}, hành vi và hiệu suất của chương trình được chú ý xem xét.",
		"right": null
	},
	{
		"question": "Trong kỹ thuật {{Kiểm thử tĩnh}}, các thuộc tính hành vi và hiệu suất của chương trình được chú ý xem xét.",
		"right": null
	},
	{
		"question": "Trong kỹ thuật nào các thuộc tính hành vi và hiệu suất của chương trình được chú ý xem xét?",
		"right": "Kiểm thử tĩnh."
	},
	{
		"question": "{{Thiết kế kiểm thử}} là quá trình sinh ra các giá trị đầu vào để đáp ứng điểu kiện bao phủ hoặc các mục đích kỹ thuật khác.",
		"right": null
	},
	{
		"question": "———— không phải là Tài liệu Thử nghiệm?",
		"right": "Chính sách kiểm tra"
	},
	{
		"question": "——————- có phải là Người kiểm tra Đơn vị Kiểm thử không?",
		"right": "Người kiểm tra độc lập"
	},
	{
		"question": "{{Gỡ lỗi || debugging}} là quá trình tìm ra chỗ sai trong mã nguồn.",
		"right": null
	},
	{
		"question": "Các mức kiểm thử hệ thống bao gồm {{kiểm thử đơn vị}}, kiểm thử mô đun, kiểm thử tích hợp và kiểm thử hệ thống.",
		"right": null
	},
	{
		"question": "Đâu không phải là lợi ích của điều kiện bao phủ (Coverage Criteria)?",
		"right": "Giúp chuyên viên kiểm thử đánh giá ca kiểm thử dễ dàng."
	},
	{
		"question": "Hoạt động đánh giá phần mềm bằng cách thực thi được gọi là {{kiểm thử}}.",
		"right": null
	},
	{
		"question": "Khái niệm nào sau đây không liên quan đến kiểm thử tĩnh?",
		"right": "Công cụ chuẩn bị dữ liệu"
	},
	{
		"question": "Kiểm thử chức năng là gì?",
		"right": "Loại thử nghiệm"
	},
	{
		"question": "Kiểm thử tích hợp là gì?",
		"right": "Mô hình SDLC"
	},
	{
		"question": "Kìm câu trả lời sai trong các câu sau?",
		"right": "Kiểm thử chỉ có thể cho thấy sự hiện diện của các lỗi và sự vắng mặt của chúng."
	},
	{
		"question": "Mô hình {{RIPR}} là viết tắt cho Reachability, Infection, Propagation, Reveal.",
		"right": null
	},
	{
		"question": "Mô hình RIPR là gì?",
		"right": "Tất cả đều đúng."
	},
	{
		"question": "Mô hình RIPR viết tắt cho những đặc trưng nào?",
		"right": "Reachability, Infection, Propagation, Reveal"
	},
	{
		"question": "Những yếu tố nào được chấp nhận bởi hành vi của phần mềm để được coi là được chấp nhận?",
		"right": "Tất cả các đáp án trên"
	},
	{
		"question": "Phát biểu nào về kiểm thử (testing) và gỡ lỗi (debugging) sau đây là đúng?",
		"right": "Kiểm thử sẽ được thực hiện để tìm ra thất bại (failure), gỡ lỗi sẽ dựa vào quá trình kiểm thử mà bị thất bại để tìm ra lỗi chương trình (fault)."
	},
	{
		"question": "Quá trình tìm lỗi sai trong mã nguồn được gọi là {{gỡ lỗi}}.",
		"right": null
	},
	{
		"question": "Tại sao không thể có khái niệm \"đúng\" (correctness) cho phần mềm?",
		"right": "Tất cả các đáp án trên"
	},
	{
		"question": "Ý nào sau đây đúng về phần mềm kiểm thử (testware) (gồm trường hợp kiểm thử (test case) và tập dữ liệu kiểm thử (test dataset))?",
		"right": "Cần quản lý cấu hình giống như yêu cầu, thiết kế và mã."
	},
	{
		"question": "Các bài kiểm thử nên được chạy theo thứ tự nào?",
		"right": "Các bài kiểm thử quan trọng nhất đầu tiên."
	},
	{
		"question": "Kỹ thuật nào sau đây là một hình thức của kiểm thử chức năng (Functional testing)?",
		"right": "Kiểm thử giá trị biên"
	},
	{
		"question": "Mô hình khuếch đại lỗi nào được sử dụng để minh họa việc tạo ra và phát hiện lỗi trong các bước sơ bộ của quy trình kỹ thuật phần mềm?",
		"right": "Tất cả các đáp án trên"
	},
	{
		"question": "Người quản lí kiểm thử (Test manager) có vai trò gì trong kiểm thử?",
		"right": "Giám sát quá trình kiểm thử."
	},
	{
		"question": "Thiết kế và xây dựng kiểm thử là giai đoạn tốn {{thời gian}} nhất của công việc kiểm thử.",
		"right": null
	},
	{
		"question": "Viết tắt thuật ngữ CASE?",
		"right": "Kỹ thuật phần mềm được ủy quyền máy tính"
	},
	{
		"question": "{{Kiểm thử hồi quy}} được thực hiện sau khi có những thay đổi trong phần mềm, để đảm bảo rằng phần mềm sau khi được cập nhật vẫn có những chức năng nó có trước khi cập nhật.",
		"right": null
	},
	{
		"question": "{{Mô hình V}} là mô hình đặc trưng cho các cấp độ kiểm thử và cách chúng liên quan đến hoạt động phát triển phần mềm.",
		"right": null
	},
	{
		"question": "Đâu không phải là một kỹ thuật kiểm thử hộp trắng?",
		"right": "Kiểm thử chuyển đổi trạng thái (State transition testing)."
	},
	{
		"question": "Đâu không phải là một mức độ kiểm thử?",
		"right": "Kiểm thử chức năng (Functional Testing)."
	},
	{
		"question": "Đâu không phải là một phương pháp tiếp cận để kiểm thử tích hợp?",
		"right": "Tất cả các phương án trên đều đúng."
	},
	{
		"question": "Đâu là mục tiêu chính của kiểm thử chấp nhận (Acceptance testing)?",
		"right": "Đánh giá phần mềm theo yêu cầu hoặc nhu cầu của người dùng."
	},
	{
		"question": "Đâu là nhược điểm của hướng tiếp cận Big Bang trong kiểm thử tích hợp?",
		"right": "Khó xác định được lỗi thuộc mô đun nào"
	},
	{
		"question": "Đâu là việc cần làm khi thực hiện kiểm thử tích hợp (Integration Testing)?",
		"right": "Kiểm tra tương tác giữa các mô đun đã được phát triển."
	},
	{
		"question": "Hoạt động kiểm thử nào được thiết kế để đánh giá các đơn vị sản xuất trong giai đoạn thực hiện?",
		"right": "Kiểm thử đơn vị (Unit testing)."
	},
	{
		"question": "Kiểm thử {{tích hợp}} (Integration testing) là kiểm thử để kiểm tra sự tương tác của các mô đun.",
		"right": null
	},
	{
		"question": "Kiểm thử để kiểm tra sự tương tác của các mô đun là:",
		"right": "Kiểm thử tích hợp (Integration testing)"
	},
	{
		"question": "Kiểm thử đơn vị được thực hiện bởi ai?",
		"right": "Nhà phát triển."
	},
	{
		"question": "Kiểm thử hệ thống thuộc loại kiểm thử nào?",
		"right": "Kiểm thử hộp đen."
	},
	{
		"question": "Kiểm thử hộp trắng thường không được sử dụng trong hoạt động kiểm thử nào?",
		"right": "Kiểm thử chấp nhận."
	},
	{
		"question": "Kiểm thử tích hợp phải giả định các mô-đun hoạt động _____________.",
		"right": "Chính xác khi chúng được kết nối với nhau."
	},
	{
		"question": "Kiểm thử từng lớp, mô đun, thành phần là:",
		"right": "Kiểm thử mô đun (Module testing)"
	},
	{
		"question": "Kiểm tra Bảng Quyết định là gì?",
		"right": "Kỹ thuật thiết kế kiểm tra hộp đen"
	},
	{
		"question": "Kỹ thuật Hộp trắng còn được gọi là gì?",
		"right": "Kiểm tra kết cấu"
	},
	{
		"question": "Loại kiểm thử nào có công việc chính là thực hiện lại một số tập hợp con các kiểm thử đã được tiến hành để đảm bảo các thay đổi không bị lan truyền?",
		"right": "Kiểm thử đơn vị."
	},
	{
		"question": "Loại kiểm thử nào sau đây thuộc về kiểm thử tích hợp trong ngữ cảnh hướng đối tượng?",
		"right": "Kiểm tra dựa trên chuỗi (Thread-based testing)."
	},
	{
		"question": "Mô hình chữ V là gì?",
		"right": "Một mô hình về vòng đời phát triển phần mềm."
	},
	{
		"question": "Mục đích chính của kiểm thử thành phần (Component Testing) là gì?",
		"right": "_x0008_Kiểm tra các hàm"
	},
	{
		"question": "Tài liệu Kiểm tra nào mô tả Tiêu chí Thoát của Kiểm tra?",
		"right": "Trường hợp thử nghiệm"
	},
	{
		"question": "Thông thường, ai là người thực hiện việc kiểm thử hệ thống (System Testing)?",
		"right": "Kiểm thử viên (Tester)."
	},
	{
		"question": "Thông thường, người thực hiện việc kiểm thử chấp nhận là?",
		"right": "Người dùng cuối."
	},
	{
		"question": "Thử nghiệm hoàn chỉnh là?",
		"right": "Không thực tế nhưng có thể"
	},
	{
		"question": "Thứ tự mà các cấp độ kiểm tra được thực hiện là:",
		"right": "Nó phụ thuộc vào bản chất của một dự án."
	},
	{
		"question": "Thứ tự thông thường của các hoạt động trong kiểm thử truyền thống là gì?",
		"right": "Kiểm thử đơn vị, kiểm thử tích hợp, kiểm thử hệ thống, kiểm thử chấp nhận."
	},
	{
		"question": "Trong kiểm thử hướng đối tượng, kiểm thử liên phương thức là như thế nào ?",
		"right": "Kiểm thử các cặp phương thức trong cùng một lớp"
	},
	{
		"question": "Trong mô hình chữ V, thông tin cho mỗi cấp độ kiểm thử thường được lấy từ đâu?",
		"right": "Các hoạt động phát triển liên kết."
	},
	{
		"question": "{{Kiểm thử hộp đen}} là kiểm thử dựa theo các mô tả bên ngoài của phần mềm, bao gồm các thông số kĩ thuật, yêu cầu và thiết kế.",
		"right": null
	},
	{
		"question": "{{Kiểm thử hộp trắng}} là quá trình kiểm thử mà kiểm thử viên kiểm tra từ mã nguồn của phần mềm.",
		"right": null
	},
	{
		"question": "Câu nhận định nào sau đây sai?",
		"right": "Kiểm thử hộp đen chỉ dùng cho kiểm thử đơn vị."
	},
	{
		"question": "Đâu không phải là ý đúng về điều kiện bao phủ?",
		"right": "Thước đo của điều kiện bao phủ là tỉ lệ phần trăm số lỗi tìm thấy"
	},
	{
		"question": "Điều nào sau đây sai khi nói về người thực hiện kiểm thử hộp đen?",
		"right": "Phải hiểu và nắm được mã nguồn."
	},
	{
		"question": "Kiểm thử hộp {{đen}} là kiểm thử chức năng.",
		"right": null
	},
	{
		"question": "Kiểm thử hộp {{trắng}} là kiểm thử cấu trúc.",
		"right": null
	},
	{
		"question": "Kiểm thử hộp trắng có thể được thực hiện khi nào?",
		"right": "Sau khi lập trình và có mã nguồn."
	},
	{
		"question": "Một miền đầu vào nhận giá trị năm sinh trong [1000, 2000]. Các giá trị biên để kiểm thử cho miền đầu vào này là:",
		"right": "1000, 2000"
	},
	{
		"question": "Phương pháp kiểm thử hộp trắng không áp dụng cho các mức độ kiểm tra phần mềm nào sau đây?",
		"right": "Kiểm thử chấp nhận (Acceptance Testing)."
	},
	{
		"question": "Ý kiến nào sau đây mô tả đúng nhất về sự khác nhau giữa kiểm thử hộp đen và kiểm thử hộp trắng?",
		"right": "Kiểm thử hộp đen là kiểm thử chức năng còn kiểm thử hộp trắng là kiểm thử cấu trúc."
	},
	{
		"question": "Báo cáo kiểm thử là đầu ra của giai đoạn nào?",
		"right": "Đánh giá kiểm thử."
	},
	{
		"question": "Câu nào sau đây là đúng về kiểm thử tích hợp thành phần?",
		"right": "Kiểm tra tương tác giữa các thành phần và thực hiện sau khi kiểm thử thành phần"
	},
	{
		"question": "Đâu là hướng tiếp cận của kiểm thử thành phần?",
		"right": "Test trước, Code sau"
	},
	{
		"question": "Đâu là một kỹ thuật đánh giá để đánh giá chất lượng của các ca kiểm thử?",
		"right": "Phân tích đột biến."
	},
	{
		"question": "Để kiểm thử toàn diện hệ thống cần có 2 hoạt động: kiểm thử dựa trên {{tiêu chí}} và kiểm thử dựa trên con người.",
		"right": null
	},
	{
		"question": "Giao diện (Interface) được kiểm thử trong pha nào?",
		"right": "Kiểm thử tích hợp"
	},
	{
		"question": "Hai phương pháp tiếp cận cho kiểm thử tích hợp là?",
		"right": "Big Bang & Incremental (Tập hợp & Tăng tiến)"
	},
	{
		"question": "Kiểm thử đơn vị được thực hiện bởi ai?",
		"right": "Người lập trình."
	},
	{
		"question": "Kiểm thử hệ thống sẽ không phát hiện được lỗi nào?",
		"right": "Cấu trúc giao tiếp không nhất quán"
	},
	{
		"question": "Kiểm thử phần mềm với dữ liệu thực trong môi trường thực được gọi là gì?",
		"right": "Kiểm thử beta."
	},
	{
		"question": "Kiểm thử tích hợp sẽ phát hiện được lỗi nào?",
		"right": "Lỗi giao tiếp giữa các thành phần"
	},
	{
		"question": "Người thực hiện công đoạn thiết kế ca kiểm thử (Test Design) không cần tìm hiểu quá rõ miền kiến thức nào sau đây?",
		"right": "Kiến thức về văn hóa"
	},
	{
		"question": "Sự khác biệt giữa kiểm thử lại và kiểm thử hồi quy là?",
		"right": "Kiểm thư lại đang chạy thử lại; Kiểm thử hồi quy sẽ tìm ra các kết quả phụ bất ngờ."
	},
	{
		"question": "Thử nghiệm Beta được thực hiện bởi ai?",
		"right": "Nhà phát triển."
	},
	{
		"question": "——————- không phải là Giai đoạn Vòng đời Kiểm tra Phần mềm?",
		"right": "Thu thập yêu cầu"
	},
	{
		"question": "{{Stress test || kiểm thử sức chịu đựng}} là kiểm thử để tìm ra giới hạn của phần mềm, bằng cách cho vào những giá trị cực lớn hay cực nhỏ, các giá trị không hợp lệ, hoặc những giá trị làm cho phần mềm không thể dự tính được trong các trường hợp bình thường.",
		"right": null
	},
	{
		"question": "{{Thiết kế kiểm thử}} là quá trình thiết kế các dữ liệu đầu vào sẽ có ảnh hưởng đến phần mềm.",
		"right": null
	},
	{
		"question": "{{Thiết kế kiểm thử}} là quá trình thiết kế các giá trị đầu vào để kiểm tra hiệu quả phần mềm.",
		"right": null
	},
	{
		"question": "Các trường hợp kiểm thử được thiết kế trong giai đoạn nào sau đây?",
		"right": "Đặc tả kiểm thử"
	},
	{
		"question": "Các trường hợp kiểm tra sẽ phát hiện ra các lỗi như:",
		"right": "Kết thúc vòng lặp không tồn tại"
	},
	{
		"question": "Giai đoạn nào ảnh hưởng nhất đến chất lượng của hệ thống?",
		"right": "Pha lên kế hoạch"
	},
	{
		"question": "Kiểm tra hệ thống là?",
		"right": "Kiểm thử hộp đen (Black box testing)"
	},
	{
		"question": "Kỹ thuật được áp dụng để kiểm tra khả năng sử dụng là?",
		"right": "Kiểm thử hộp đen (Black box testing)"
	},
	{
		"question": "Kỹ thuật Hộp trắng cũng được phân loại là?",
		"right": "Kiểm thử cấu trúc"
	},
	{
		"question": "Lỗi nào sau đây không nên được kiểm tra khi xử lý lỗi được đánh giá?",
		"right": "Mô tả lỗi khó hiểu"
	},
	{
		"question": "Mức độ chi tiết nào của thử nghiệm kiểm tra hành vi hợp tác của mô-đun?",
		"right": "Kiểm thử tích hợp."
	},
	{
		"question": "Người kiểm tra phải có kiến thức về miền ứng dụng của phần mềm, kiểm tra và {{giao diện người dùng}}.",
		"right": null
	},
	{
		"question": "Nội dung nào sau đây không phải là một phần của tài liệu thiết kế thử nghiệm?",
		"right": "Nhật ký kiểm thử"
	},
	{
		"question": "Phân tích tĩnh KHÔNG tìm thấy gì?",
		"right": "Việc sử dụng một biến trước khi nó được định nghĩa"
	},
	{
		"question": "Tại sao kiểm thử tự động không dễ để thực hiện?",
		"right": "Bởi vì bảo trì hệ thống kiểm thử rất khó"
	},
	{
		"question": "Thiết kế các mẫu kiểm thử dựa trên phần kiến thức của chương trình và con người là {{kiểm thử dựa trên suy nghĩ của con người||human-based testing)}}.",
		"right": null
	},
	{
		"question": "{{Tự động hóa kiểm thử}} là là quá trình nhúng các giá trị kiểm thử vào các tập lệnh thực thi.",
		"right": null
	},
	{
		"question": "Khả năng kiểm thử (Testability) của một ca kiểm thử bị chi phối bởi các vấn đề nào?",
		"right": "Vấn đề chọn giá trị để đưa vào bộ kiểm thử, và vấn đề quan sát hành vi và kết quả khi bộ kiểm thử được thực thi."
	},
	{
		"question": "Kiểm thử đơn vị (Unit test) được thực hiện bởi",
		"right": "Người lập trình"
	},
	{
		"question": "Kiểm thử nào đề cập đến việc kiểm thử lại một đơn vị, tích hợp và hệ thống sau khi sửa đổi, để chắc chắn rằng sự thay đổi đó không tạo ra các lỗi mới?",
		"right": "Kiểm thử quy hồi (Regression Test)."
	},
	{
		"question": "Mục đích nào sau đây của kiểm thử tự động là KHÔNG ĐÚNG?",
		"right": "Có thể kiểm thử được giao diện và trải nghiệm người dùng (UI\\/UX)."
	},
	{
		"question": "Hoạt động nào sau đây đòi hỏi các kỹ năng máy tính cơ bản và không yêu cầu cao về kiến thức kỹ thuật?",
		"right": "Thực thi kiểm thử (Test Execution)"
	},
	{
		"question": "Kiểm tra hành vi là?",
		"right": "Kiểm thử hộp đen"
	},
	{
		"question": "Loại kiểm thử nào sau đây không phải là một phần của kiểm thử hệ thống?",
		"right": "Kiểm thử ngẫu nhiên"
	},
	{
		"question": "Phân tích giá trị biên thuộc về?",
		"right": "Kiểm thử hộp đen (Black box testing)"
	},
	{
		"question": "Trong chiến lược kiểm thử nào sau đây, đơn vị nhỏ nhất có thể kiểm tra được là lớp hoặc đối tượng được đóng gói?",
		"right": "Kiểm thử thành phần"
	},
	{
		"question": "{{Đánh giá thử nghiệm}} là quá trình đánh giá kết quả của thử nghiệm và báo cáo cho các nhà phát triển.",
		"right": null
	},
	{
		"question": "Cái nào không phải là một phần của Kiểm tra thông số kỹ thuật?",
		"right": "Phân vùng tương đương"
	},
	{
		"question": "Fault Masking là gì?",
		"right": "Tạo một trường hợp thử nghiệm không để lộ lỗi"
	},
	{
		"question": "Khi thực hiện đánh giá kiểm thử, kiến thức nào sau đây là không cần thiết?",
		"right": "Kiến thức về y học."
	},
	{
		"question": "Thử nghiệm khám phá là gì?",
		"right": "Kỹ thuật thiết kế thử nghiệm dựa trên kinh nghiệm"
	},
	{
		"question": "Các trường hợp kiểm tra bắt nguồn từ các ca sử dụng",
		"right": "Hữu ích nhất trong việc phát hiện ra các khiếm khuyết trong các luồng quy trình trong quá trình sử dụng hệ thống trong thế giới thực"
	},
	{
		"question": "Bạn không nên tự động hóa trường hợp kiểm thử nào?",
		"right": "Các thử nghiệm không yêu cầu thực hiện lại."
	},
	{
		"question": "Các trường hợp kiểm thử được thiết kế trong giai đoạn nào sau đây?",
		"right": "Đặc điểm kỹ thuật kiểm thử."
	},
	{
		"question": "Cách tiếp cận nào sau đây là tốt nhất cho tự động hóa trong dài hạn?",
		"right": "Xây dựng một đội với các thành viên có kỹ năng phát triển."
	},
	{
		"question": "Cách tiếp cận nào sau đây là tốt nhất cho tự động hóa trong dài hạn?",
		"right": "Xây dựng một đội với các thành viên có kỹ năng phát triển"
	},
	{
		"question": "Đặc điểm nào sau đây không phải là đặc điểm của công cụ tự động hóa tốt?",
		"right": "Tích hợp dễ dàng với các công cụ CI."
	},
	{
		"question": "Đâu không không phải là một loại kiểm thử?",
		"right": "Kiểm thử xác nhận."
	},
	{
		"question": "Đâu không phải là mục tiêu của kiểm thử tự động (Test Automation)?",
		"right": "Giúp chương trình được kiểm thử có nhiều tính năng hơn."
	},
	{
		"question": "Đâu không phải là ưu điểm của kiểm thử tự động?",
		"right": "Hiểu hơn về hệ thống."
	},
	{
		"question": "Điều nào sau đây không phải là nhược điểm của kiểm thử tự động hóa?",
		"right": "Kiểm thử tự động không khả thi đối với chức năng mới."
	},
	{
		"question": "Điều nào sau đây không phải là nhược điểm của kiểm thử tự động?",
		"right": "Kiểm thử tự động không khả thi đối với chức năng mới"
	},
	{
		"question": "Điều nào sau đây không phải là ưu điểm của kiểm thử tự động ?",
		"right": "Nó có thể giúp xác định các trường hợp kiểm thử ưu tiên cao"
	},
	{
		"question": "Điều nào sau đây không phải là ưu điểm của kiểm thử tự động?",
		"right": "Khả năng bao phủ cao (High coverage)."
	},
	{
		"question": "Điều nào sau đây không phải là yêu cầu tiên quyết cho kiểm thử tự động hóa?",
		"right": "Tập lệnh kiểm thử (Test Script) sẵn sàng."
	},
	{
		"question": "Điều nào sau đây là ưu điểm của kiểm thử tự động?",
		"right": "Khả năng lặp (Repeatability)."
	},
	{
		"question": "JUnit có hỗ trợ cơ chế sinh các ca kiểm thử không?",
		"right": "Không."
	},
	{
		"question": "JUnit là công cụ cho các đơn vị kiểm thử được viết bằng?",
		"right": "Java."
	},
	{
		"question": "Khả năng kiểm tra bị chi phối bởi mấy vấn đề thực tế?",
		"right": 2
	},
	{
		"question": "Kiểm thử đơn vị (Unit test) được thực hiện bời ai?",
		"right": "Người lập trình"
	},
	{
		"question": "Kiểm thử dựa trên danh sách kiểm tra có thể dừng nếu",
		"right": "Mỗi mục trên danh sách kiểm tra được kiểm tra và thông qua (pass)"
	},
	{
		"question": "Kiểm thử hoàn chỉnh là:",
		"right": "Không thực tế nhưng có thể."
	},
	{
		"question": "Lý do nào sau đây không phải là lý do hợp lệ để tự động hóa (automating) trường hợp kiểm thử (test case)?",
		"right": "Bài kiểm thử (test) cho kết quả không liên tục và không thể kiểm tra bằng tay."
	},
	{
		"question": "Lý do nào sau đây không phải là lý do hợp lệ để tự động hóa trường hợp kiểm thử?",
		"right": "Kiểm thử cho kết quả không liên tục và không thể kiểm thử bằng tay"
	},
	{
		"question": "Mục đích của bộ mô phỏng trong kiểm thử tự động là gì?",
		"right": "Mô phỏng quá trình thực hiện của chương trình cần kiểm thử."
	},
	{
		"question": "Phương thức assertNotNull() thất bại khi nào?",
		"right": "Tham chiếu đối tượng Null."
	},
	{
		"question": "Phương thức nào trong JUnit được sử dụng để giúp tránh được việc trùng mã khi nhiều test cùng chia sẻ nhau ở phần khởi tạo và dọn dẹp các biến?",
		"right": "Setup() và TearDown()."
	},
	{
		"question": "Phương thức Void fail() trong JUnit thường được ưu tiên khi xử lý các {{ngoại lệ}}.",
		"right": null
	},
	{
		"question": "Tại sao lại thực hiện kiểm thử tự động (Automation testing)?",
		"right": "Cải thiện hiệu quả của kiểm thử"
	},
	{
		"question": "Trong một bộ công cụ kiểm thử tự động, công cụ nào cho phép quản lý việc thực hiện\\/thực thi các ca kiểm thử?",
		"right": "Quản lý kiểm thử."
	},
	{
		"question": "—————– không phải là Loại thử nghiệm?",
		"right": "Kiểm tra cơ sở dữ liệu"
	},
	{
		"question": "{{Khả năng kiểm thử phần mềm}} là mức độ mà một hệ thống hay một thành phần tạo điều kiện thuận lợi cho việc thiết lập các tiêu chí kiểm thử và thực hiện các kiểm thử để xác định xem các tiêu chí đó đã được đáp ứng chưa.",
		"right": null
	},
	{
		"question": "{{Khả năng kiểm tra}} là mức độ mà hệ thống tạo điều kiện thuận lợi cho việc thiết lập các tiêu chí thử nghiệm và thực hiện các thử nghiệm đó.",
		"right": null
	},
	{
		"question": "Lý thuyết số Cyclomatic trong một đồ thị được định nghĩa bởi ________",
		"right": "e - n + 2"
	},
	{
		"question": "Tính {{điều khiển || controllability}} của phần mềm thể hiện mức độ dễ dàng để chúng ta có thể cung cấp cho phần mềm những đầu vào cần thiết.",
		"right": null
	},
	{
		"question": "Tính {{quan sát || observability}} của phần mềm thể hiện mức độ dễ dàng để chúng ta có thể theo dõi được trạng thái của phần mềm.",
		"right": null
	},
	{
		"question": "Tính dễ kiểm thử đánh giá bởi bởi tính dễ quan sát và {{dễ điều khiển}}.",
		"right": null
	},
	{
		"question": "V&V trong kiểm thử phần mềm được hiểu là thế nào? (Vì đáp án không có nghĩa rõ ràng trong tiếng việt, nên sẽ để tiếng anh).",
		"right": "Verification and Validation."
	},
	{
		"question": "Giá trị cần thiết để xem kết quả của giá trị trường hợp thử nghiệm (test case) là gì?",
		"right": "Giá trị xác minh (Verification Values)"
	},
	{
		"question": "Kết quả {{mong đợi}} là kết quả được tiến hành bởi các bài kiểm thử nếu như phần mềm có các hành vi giống với mong đợi.",
		"right": null
	},
	{
		"question": "Khai niệm bộ kiểm thử là gì?",
		"right": "Một tập các ca kiểm thử."
	},
	{
		"question": "Tiêu chuẩn nào sau đây là tiêu chuẩn kiểm thử thành phần?",
		"right": "BS7925-2"
	},
	{
		"question": "{{Khung kiểm thử}} là một tập hợp các giả định, khái niệm và các công cụ hỗ trợ tự động hóa kiểm tra.",
		"right": null
	},
	{
		"question": "Đâu không phải là mô hình kiểm thử tự động (Test Automation Framework)?",
		"right": "Hướng đối tượng (Object-Oriented Development Framework)."
	},
	{
		"question": "Khai niệm khung phần mềm kiểm thử tự động là gì?",
		"right": "Một tập hợp các giả định, khái niệm và công cụ hỗ trợ tự động hóa kiểm thử."
	},
	{
		"question": "Loại trường hợp kiểm thử (test case) nào sau không nên tự động hóa (automation)?",
		"right": "Các thử nghiệm không yêu cầu thực hiện lại."
	},
	{
		"question": "Câu nào là đúng về các phương thức của JUnit?",
		"right": "Tất cả các phương thức đều trả về void."
	},
	{
		"question": "Câu nào sau đây là đúng về JUnit?",
		"right": "JUnit có thể sử dụng hàm main() để chạy các ca kiểm thử."
	},
	{
		"question": "—————— không phải là Cấp độ Thử nghiệm?",
		"right": "Kiểm tra hệ thống"
	},
	{
		"question": "Chú thích (Annotation) nào sau đây để đánh dấu phương thức được gọi trước khi thực thi mỗi phương thức @Test được gọi?",
		"right": "@Before"
	},
	{
		"question": "Chú thích (Annotation) nào sau đây để đánh dấu phương thức được gọi trước khi thực thi tất cả phương thức @Test được gọi?",
		"right": "@BeforeClass"
	},
	{
		"question": "Chú thích nào định nghĩa một kiểm tra JUnit?",
		"right": "@Test"
	},
	{
		"question": "Đâu là một vòng đời của một ca kiểm thử JUnit?",
		"right": "@BeforeClass -> @Before -> @Test -> @After -> @AfterClass"
	},
	{
		"question": "Hàm nào thuộc lớp Assert kiểm tra 2 đối tượng cùng trỏ tới một đối tượng?",
		"right": "void assertSame(expected, actual)"
	},
	{
		"question": "Junit không được sử dụng để kiểm thử yếu tố nào?",
		"right": "Một biến dữ liệu."
	},
	{
		"question": "JUnit là công cụ giúp kiểm thử {{tự động}}.",
		"right": null
	},
	{
		"question": "JUnit là gì?",
		"right": "Công cụ giúp kiểm thử tự động."
	},
	{
		"question": "Lớp Assert nào sẽ so sánh và kiểm tra 2 giá trị đầu vào?",
		"right": "assertEquals()"
	},
	{
		"question": "Một lớp kiểm thử không bao gồm những gì?",
		"right": "Chương trình được kiểm thử"
	},
	{
		"question": "Phương thức {{@Before}} gọi mỗi lần trước mỗi ca kiểm thử.",
		"right": null
	},
	{
		"question": "Ý kiến nào sau đây sai về JUnit?",
		"right": "JUnit tự động sửa lỗi trong mã nguồn, giúp tiết kiệm thời gian kiểm thử và phát triển phần mềm."
	},
	{
		"question": "{{Kiểm thử dựa trên dữ liệu}} là phương pháp viết kiểm thử một lần rồi sau đó cung cấp giá trị dữ liệu qua một bảng.",
		"right": null
	},
	{
		"question": "Đâu là nhược điểm của mô hình kiểm thử hướng dữ liệu (Data-Driven Testing Framework)?",
		"right": "Người kiểm thử phải có kĩ năng lập trình nhất định."
	},
	{
		"question": "{{Tích hợp liên tục}} ��ảm bảo rằng phần mềm luôn được thỏa mãn các ca kiểm thử mỗi khi có cập nhật mới.",
		"right": null
	},
	{
		"question": "Đâu không phải là ưu điểm của tích hợp liên tục?",
		"right": "Các sai lầm (mistakes) diễn ra muộn hơn."
	},
	{
		"question": "Hạn chế của kiểm thử dựa trên danh sách kiểm tra (checklist) là gì?",
		"right": "Nó không có đủ thông tin để tái kiểm tra"
	},
	{
		"question": "{{Phương pháp linh hoạt (Agile)}} là phương pháp giúp phần mềm bắt đầu từ nhỏ và tiến hóa theo thời gian thay vì \"chiến đấu\" với nó.",
		"right": null
	},
	{
		"question": "Công nghệ phần mềm truyền thống tập trung chủ yếu vào mô hình hóa mở rộng và {{phân tích trả trước}} với mục đích là để làm bộc lộ những vấn đề và những thay đổi tiềm ẩn càng sớm càng tốt.",
		"right": null
	},
	{
		"question": "Trong những ngày đầu của kỹ thuật phần mềm, lĩnh vực này đã tạo ra hai các giả định để cho phép kỹ thuật phần mềm truyền thống chế ngự hiệu quả đường cong chi phí thay đổi, đó là những giả định nào?",
		"right": "Cả 2 đáp án 1 và 2"
	},
	{
		"question": "Đâu không phải là loại kiểm thử Test-Driven Development?",
		"right": "Kiểm thử hệ thống (System Testing)."
	},
	{
		"question": "Đâu là nhược điểm của phát triển hướng kiểm thử (Test-Driven Development)?",
		"right": "Phải cập nhật lại các ca kiểm thử khi yêu cầu thay đổi."
	},
	{
		"question": "Ở cấp độ rộng nhất, các phương pháp nhanh (agile methods) bao gồm đạt được kết quả cuối cùng chính (achieving key end results) là những gì?",
		"right": "Cả 2 đáp án 1 và 2"
	},
	{
		"question": "Tại sao chi phí phát triển ngày càng tăng?",
		"right": "Cả 2 đáp án 1 và 2"
	},
	{
		"question": "Kiểm thử mô hình Agile yêu cầu phần mềm bắt đầu đơn giản và {{tiến hóa}} theo thời gian.",
		"right": null
	},
	{
		"question": "Kiểm thử trong mô hình {{Agile}} chỉ kiểm thử một số giá trị đại diện của phần mềm.",
		"right": null
	},
	{
		"question": "Trong phương thức Agile, {{các trường hợp thử nghiệm}} là đặc tả thực tế cho hệ thống.",
		"right": null
	},
	{
		"question": "——————- có phải là Người kiểm tra Kiểm thử Hệ thống không?",
		"right": "Nhà phát triển"
	},
	{
		"question": "Một máy chủ tích hợp liên tục thực hiện những công việc nào khi có cập nhật mới trong kho lưu trữ?",
		"right": "Xây dựng lại hệ thống, trả về và xác minh lại những ca kiểm thử."
	},
	{
		"question": "Tích hợp {{liên tục}} đảm bảo rằng phần mềm luôn được thỏa mãn các ca kiểm thử mỗi khi có cập nhật mới.",
		"right": null
	},
	{
		"question": "Trong tích hợp liên tục (Continuos Integration), mỗi sự tích hợp sẽ được kiểm định lại bởi một build tự động để phát hiện ra {{lỗi tích hợp}} càng sớm càng tốt.",
		"right": null
	},
	{
		"question": "{{Tích hợp liên tục}} là quá trình hệ thống sẽ được tái xây dựng và tái kiểm thử mỗi khi có một thay đổi nào được đẩy (commit) vào mã nguồn.",
		"right": null
	},
	{
		"question": "Các phương pháp Agile mong đợi phần mềm ____",
		"right": "bắt đầu nhỏ và phát triển theo thời gian"
	},
	{
		"question": "Chiến lược nào sau đây là một chiến lược của kiểm thử hộp đen?",
		"right": "Xây dựng đồ thị nhân-quả."
	},
	{
		"question": "Đặc điểm nào sau đây không phải của câu chuyện người dùng (user stories)?",
		"right": "Chi tiết và mô tả rõ các yêu cầu bằng ngôn ngữ kỹ thuật."
	},
	{
		"question": "Hoạt động nào không phải là hoạt động SQA?",
		"right": "Kiểm thử hộp trắng."
	},
	{
		"question": "Hộp nào xác định hành vi của một hệ thống hoặc một phần của hệ thống?",
		"right": "Hộp đen (Black box)."
	},
	{
		"question": "Khái niệm hộp đen dựa trên (các) giả định rằng:",
		"right": "Hệ thống siêu ổn định."
	},
	{
		"question": "Kiểm thử hệ thống là một:",
		"right": "Kiểm thử hộp đen."
	},
	{
		"question": "Kiểm thử hộp trắng có thể được bắt đầu:",
		"right": "Sau khi lập trình."
	},
	{
		"question": "Kỹ thuật kiểm thử hộp đen nào phù hợp với mọi cấp độ kiểm thử?",
		"right": "Phân vùng tương đương."
	},
	{
		"question": "Kỹ thuật nào sau đây được áp dụng để kiểm thử khả năng sử dụng (usability testing) của phần mềm?",
		"right": "Kiểm thử hộp đen."
	},
	{
		"question": "Một nhược điểm của kiểm thử nhanh (Agile Testing) là gì?",
		"right": "Kiểm thử nhanh chỉ tập trung vào kiểm thử hệ thống trong điều kiện sử dụng \"bình thường\", không tập trung vào các trường hợp đặc biệt."
	},
	{
		"question": "Những điều sau đây là một phần của kiểm thử hệ thống?",
		"right": "Kiểm thử hiệu năng, kiểm thử tốc độ tải và kiểm thử khả năng chịu tải."
	},
	{
		"question": "Phân tích giá trị biên thuộc về loại kiểm thử nào?",
		"right": "Kiểm thử hộp đen."
	},
	{
		"question": "Phát triển phần mềm dựa trên kiểm thử (Test-driven Development) là gì?",
		"right": "Là quá trình mà trước tiên mình phải viết một bộ kiểm thử mà chương trình chạy không đúng trước khi viết chức năng phù hợp với bộ kiểm thử đấy."
	},
	{
		"question": "Quá trình hệ thống sẽ được tái xây dựng và tái kiểm thử mỗi khi có một thay đổi nào được đẩy (push) vào mã nguồn là gì?",
		"right": "Tích hợp liên tục (Continuous Integration)."
	},
	{
		"question": "Sự khác biệt chính giữa kiểm thử chương trình và kiểm thử hệ thống là gì?",
		"right": "Kiểm thử hệ thống tập trung vào kiểm tra giao diện giữa các chương trình, kiểm thử chương trình tập trung vào các chương trình riêng lẻ."
	},
	{
		"question": "Thứ tự các Cấp độ Kiểm tra được thực hiện là?",
		"right": "Đơn vị, Tích hợp, Chấp nhận, Hệ thống"
	},
	{
		"question": "Tích hợp liên tục (Continuous Integration) là gì?",
		"right": "Là quá trình hệ thống sẽ được tái xây dựng và tái kiểm thử mỗi khi có một thay đổi nào được đẩy (commit) vào mã nguồn."
	},
	{
		"question": "{{Cải tiến || Refactoring}} là quá trình cải tiến code có thể kiểm soát được mà không tạo ra chức năng mới.",
		"right": null
	},
	{
		"question": "{{Tái cấu trúc}} là một cách để sửa đổi (và hi vọng sẽ cải thiện) cấu trúc của mã hiện có mà không thay đổi hành vi của mã đó.",
		"right": null
	},
	{
		"question": "Trong thiết kế hướng kiểm thử, khi một thay đổi được thực hiện, kiểm thử viên sẽ làm gì?",
		"right": "Thêm một ca kiểm thử ứng với thay đổi đó"
	},
	{
		"question": "Đâu không phải là nhược điểm của quá trình kiểm thử trong mô hình Agile ?",
		"right": "Công việc kiểm thử tay nhàm chán, độ đồng hóa không cao."
	},
	{
		"question": "Phát triển theo h��ớng kiểm thử có khả năng nào?",
		"right": "Dễ dàng thêm kiểm thử TDD cho mỗi lần cải tiến"
	},
	{
		"question": "Câu nào sau đây đúng khi nói về kiểm thử truyền thống (traditional testing)?",
		"right": "Nhược điểm chính của kiểm thử truyền thống là tốn nhân lực và tốn thời gian"
	},
	{
		"question": "Chiến lược kiểm thử hộp trắng sử dụng phương pháp kiểm thử nào sau đây?",
		"right": "Kiểm thử dòng điều khiển."
	},
	{
		"question": "Kỹ thuật kiểm thử nào sau đây thuộc kiểm thử hộp đen?",
		"right": "Kỹ thuật phân lớp tương đương."
	},
	{
		"question": "Kỹ thuật kiểm thử nào sau đây thuộc kiểm thử hộp trắng?",
		"right": "Kiểm thử đường cơ bản - Đồ thị dòng."
	},
	{
		"question": "{{Mức độ bao phủ}} được đo bằng tỉ lệ giữa số các yêu cầu kiểm thử được thỏa mãn bởi tập kiểm thử T và kích thước của tập yêu cầu kiểm thử TR.",
		"right": null
	},
	{
		"question": "Các điều kiện bao phủ (Coverage Criterion) thường có liên hệ với nhau, và được so sánh trên phương diện {{quan hệ bao hàm}}.",
		"right": null
	},
	{
		"question": "Cho một bộ yêu cầu kiểm thử TR và một bộ kiểm thử T thỏa mãn mọi yêu cầu, T là nhỏ nhất khi:",
		"right": "Nếu không có bộ kiểm thử nào nhỏ hơn mà cũng thỏa mãn toàn bộ yêu cầu kiểm thử."
	},
	{
		"question": "Đâu là thước đo để đánh giá mã nguồn sau khi đã thực hiện các ca kiểm thử?",
		"right": "Bao phủ mã nguồn"
	},
	{
		"question": "Đâu là tiêu chuẩn phủ tốt nhất theo chuẩn công nghiệp?",
		"right": "MCDC."
	},
	{
		"question": "Độ bao phủ dòng lệnh (Statement Coverage) sẽ không kiểm tra yếu tố nào sau đây?",
		"right": "Các câu lệnh bị thiếu."
	},
	{
		"question": "Đối tượng nào sau đây thường ưu tiên việc tạo các giá trị thử nghiệm bên ngoài và đo lường dựa trên tiêu chí?",
		"right": "Các tập đoàn và doanh nghiệp."
	},
	{
		"question": "Đối tượng nào sau đây thường ưu tiên việc trực tiếp tạo các giá trị thử nghiệm để đáp ứng tiêu chí?",
		"right": "Các bên nghiên cứu trong cộng đồng."
	},
	{
		"question": "Mã nguồn {{không}} được coi là một mô hình.",
		"right": null
	},
	{
		"question": "Mức độ bao phủ (Coverage level) là gì?",
		"right": "Là tỷ lệ giữa số lượng yêu cầu thử nghiệm được thỏa mãn so với kích thước của TR."
	},
	{
		"question": "Tại sao ta sử dụng tiêu chuẩn bao phủ?",
		"right": "Vì chúng ta không thể kiểm thử với mọi đầu vào."
	},
	{
		"question": "Trong các đặc điểm trên đâu là đặc điểm của một tiêu chí bao phủ tốt?",
		"right": "Cả 3 đặc điểm trên."
	},
	{
		"question": "{{Tiêu chí bao phủ}} là một quy tắc hoặc một tập hợp các quy tắc áp đặt các yêu cầu kiểm thử lên các bộ kiểm thử.",
		"right": null
	},
	{
		"question": "Cho 3 điều kiện bao phủ C1 nằm trong C2 nằm trong C3. Biết rằng bộ kiểm thử T1, T2, T3 lần lượt thoả mãn C1, C2, C3 trên cùng một chương trình P. Điều kiện nào sau đây sai?",
		"right": "T2 cần thoả mãn C1"
	},
	{
		"question": "Đâu không phải là lợi ích từ việc sử dụng các tiêu chuẩn bao phủ?",
		"right": "Phát triển phần mềm nhanh hơn để đưa đến cho khách hàng."
	},
	{
		"question": "Đâu không phải là mục đích của việc sử dụng tiêu chuẩn bao phủ?",
		"right": "Để sinh ra được càng nhiều ca kiểm thử có thể, nhằm bao phủ được toàn bộ chương trình."
	},
	{
		"question": "Đâu không phải là rào cản để áp dụng kiểm thử dựa trên tiêu chí?",
		"right": "Am hiểu sâu rộng về kiểm thử."
	},
	{
		"question": "Đâu không phải ưu điểm của việc áp dụng kiểm thử tự động và kiểm thử dựa theo tiêu chí?",
		"right": "Kiểm thử viên cần làm việc thủ công."
	},
	{
		"question": "Khi lựa chọn tiêu chí kiểm thử, kiểm thử viên cần cân bằng giữa {{chi phí}} và {{hiệu quả}} của các tiêu chí dựa trên phần mềm được kiểm thử.",
		"right": null
	},
	{
		"question": "Khi lựa chọn tiêu chí kiểm thử, kiểm thử viên cần cân bằng giữa các tiêu chí nào?",
		"right": "Chi phí và độ hiệu quả."
	},
	{
		"question": "Một trong những ưu điểm của thiết kế ca kiểm thử dựa trên {{tiêu chí}} là thuận tiền hơn để tự động hóa.",
		"right": null
	},
	{
		"question": "Yếu tố nào sau đây có thể được sử dụng để đánh giá các tiêu chí về độ bao phủ?",
		"right": "Mức độ hiệu quả khi đưa vào kiểm thử."
	},
	{
		"question": "{{Không gian đầu vào}} là tất cả các đầu vào có thể có của một chương trình.",
		"right": null
	},
	{
		"question": "{{Miền đầu vào}} là tất cả đầu vào có thể có cho một chương trình.",
		"right": null
	},
	{
		"question": "Bước thứ năm của mô hình hóa miền đầu vào (IDM) là?",
		"right": "Làm mịn tổ hợp các khối thành các đầu vào kiểm thử."
	},
	{
		"question": "D720=",
		"right": 2
	},
	{
		"question": "Đâu không là lợi ích của phân vùng không gian đầu vào?",
		"right": "Tiện tích trong kiểm thử."
	},
	{
		"question": "Đâu không phải là lợi ích của kiểm thử phân hoạch không gian đầu vào?",
		"right": "Luôn sinh ra ít ca kiểm thử hơn các mô hình kiểm thử khác."
	},
	{
		"question": "Đâu không phải là lợi ích của kiểm thử phân hoạch?",
		"right": "Đảm bảo độ tin cậy sản phẩm"
	},
	{
		"question": "Đâu KHÔNG PHẢI là ý đúng khi nói về phân hoạch giá trị đầu vào (Input Space Partitioning)?",
		"right": "Phân hoạch giá trị đầu vào chỉ áp dụng cho các phương pháp kiểm thử đã lỗi thời (như kiểm thử truyền thống)."
	},
	{
		"question": "Đâu không phải mối quan hệ trong kiểm thử phân hoạch (partition-based testing)?",
		"right": "Bao phủ"
	},
	{
		"question": "Đâu không phải một trong các bước của mô hình hóa miền đầu vào?",
		"right": "Nhận biết các lỗi hiện có trong phần mềm."
	},
	{
		"question": "Kĩ thuật kiểm thử phân hoạch theo không gian đầu vào không được áp dụng ở mức độ kiểm thử nào?",
		"right": "Kiểm thử chấp nhận."
	},
	{
		"question": "Kiểm thử giá trị biên là gì?",
		"right": "Kiểm thử ranh giới mà phân biệt điều kiện hợp lệ và không hợp lệ"
	},
	{
		"question": "Một biến đầu nhận giá trị năm sinh có khoảng từ năm 1900 và 2010. Các giá trị biên để kiểm thử biến này là?",
		"right": "1899, 1900, 1901, 2009, 2010, 2011"
	},
	{
		"question": "Một chương trình xác nhận một khoảng như sau: giá trị nhỏ hơn 20 hoặc lớn hơn 30 không được chấp thuận, giá trị từ 20 đến 30 được chấp nhận. Các giá trị đầu vào nào sau đây nằm cùng trong một phân vùng tương đương?",
		"right": "20, 25, 30"
	},
	{
		"question": "Một trường dữ liệu nhận giá trị năm sinh trong khoảng [1000, 2000]. Các giá trị biên để kiểm thử\r\ncho trường dữ liệu này là?",
		"right": "1000, 1001, 1090, 1999, 2000"
	},
	{
		"question": "Phương pháp phân hoạch miền giá trị đầu vào dựa trên giao diện (Interface-based approach) là gì?",
		"right": "Phát triển các đặc tính (characteristic) dựa trên các giá trị đầu vào đã được tách riêng biệt."
	},
	{
		"question": "Phương pháp phân hoạch miền giá trị đầu vào dựa trên tính năng (Functionality-based approach) là gì?",
		"right": "Phát triển các đặc tính dựa trên các tính năng (functionality) của hệ thống đang kiểm thử"
	},
	{
		"question": "Ý nào sau đây thỏa mãn điều kiện khi phân mảnh?",
		"right": "Các khối (block) không được giao nhau."
	},
	{
		"question": "Bước đầu tiên của thiết kế theo miền đầu vào là gì?",
		"right": "Xác định những chức năng kiểm thử được."
	},
	{
		"question": "Bước đầu tiên trong 5 bước của quá trình mô hình hóa miền đầu vào (IDM) là?",
		"right": "Nhận biết các chức năng có thể kiểm thử được."
	},
	{
		"question": "Bước đầu tiên trong việc mô hình hóa miền đầu vào là gì?",
		"right": "Xác định các chức năng có thể kiểm tra."
	},
	{
		"question": "Bước số 2 của việc mô hình hóa miền không gian đầu vào là gì?",
		"right": "Tìm tất cả thông số."
	},
	{
		"question": "các hệ thống lớn chắc chắn có thể phù hợp với cách tiếp cận phân vùng không gian đầu vào và các hệ thống như vậy thường cung cấp chức năng {{phức tạp}}",
		"right": null
	},
	{
		"question": "Cách tiếp cận thiết kế theo miền đầu vào nào thường dẫn đến những ca kiểm thử chất lượng hơn?",
		"right": "Tiếp cận theo chức năng."
	},
	{
		"question": "Chiến lược nào không được sử dụng để xác định giá trị cho miền đầu vào?",
		"right": "Cố gắng tối thiểu số khối trong từng đặc tính."
	},
	{
		"question": "Đâu không phải là phân hoạch miền đầu vào các số nguyên?",
		"right": "Số không dương, số không âm, số 0."
	},
	{
		"question": "Hai phương pháp tiếp cận trong việc mô hình hóa miền đầu vào là phương pháp {{dựa trên giao diện}} và phương pháp {{dựa trên chức năng}}.",
		"right": null
	},
	{
		"question": "Khẳng định nào sau đây không đúng khi nói về về mô hình hóa miền đầu vào (IDM) theo hướng tiếp cận dựa trên chức năng?",
		"right": "Phát triển các đặc tính (characteristics) trực tiếp từ các tham số đ��u vào riêng lẻ."
	},
	{
		"question": "Miền đầu vào là {{các giá trị}} có thể mà tham số đầu vào có thể có.",
		"right": null
	},
	{
		"question": "Mỗi phương pháp công khai thường là một chức năng có thể kiểm tra được cần được {{kiểm tra riêng lẻ}}",
		"right": null
	},
	{
		"question": "Phân mảnh phải thỏa mãn hai điều kiện {{đầy đủ, rời rạc}}.",
		"right": null
	},
	{
		"question": "Theo định nghĩa, đầu vào kiểm tra sử dụng gì?",
		"right": "Chính xác một khối từ mỗi đặc tính"
	},
	{
		"question": "Từ quan điểm của đặc tính cụ thể, tất cả các giá trị trong mỗi khối được coi là {{tương đương}}.",
		"right": null
	},
	{
		"question": "Cách tiếp cận theo giao diện bỏ qua {{mối quan hệ giữa các tham số}}.",
		"right": null
	},
	{
		"question": "Đâu là điểm mạnh của phương pháp dựa theo giao diện với mẫu miền đầu vào?",
		"right": "Xác định các đặc tính."
	},
	{
		"question": "Kĩ thuật kiểm thử phân vùng không gian đầu vào có thể được áp dụng dễ dàng mà không cần {{tự động hóa}}.",
		"right": null
	},
	{
		"question": "Phương pháp phát triển các đặc tính trực tiếp từ các tham số đầu vào cho chương trình đang thử nghiệm với mẫu miền đầu vào là gì?",
		"right": "Phương pháp dựa trên giao diện."
	},
	{
		"question": "Tiếp cận theo hướng {{giao diện}} phát triển các đặc tính từ các tham số đầu vào độc lập.",
		"right": null
	},
	{
		"question": "Ý nào sau đây thỏa mãn khi tiếp cận hướng giao diện (Interface-Based Approach)?",
		"right": "Coi mỗi tham số độc lập nhau."
	},
	{
		"question": "Đâu không phải đặc điểm của cách tiếp cận dựa trên chức năng đối với việc mô hình hóa nguồn dữ liệu đầu vào?",
		"right": "Phát triển các đặc tính trực tiếp từ các tham số đầu vào riêng lẻ."
	},
	{
		"question": "Tiếp cận theo hướng {{chức năng}} phát triển các đặc tính từ các hành vi hệ thống khi kiểm thử.",
		"right": null
	},
	{
		"question": "Trong việc thiết kế miền đầu vào, ta có thể chấp nhận các mô hình miền đầu vào khác nhau mà có sự {{trùng lặp}}.",
		"right": null
	},
	{
		"question": "Mọi {{phân hoạch}} phải chấp nhận toàn bộ giá trị, dù giá trị đó hợp lệ hay không hợp lệ.",
		"right": null
	},
	{
		"question": "Phân vùng của một tập hợp các giá trị trong miền của một đặc tính được gọi là gì?",
		"right": "Khối."
	},
	{
		"question": "Việc mọi phân vùng đều phải tiếp nhận tất cả các giá trị, kể cả giá trị không hợp lệ thể hiện tính {{đầy đủ}} của phương pháp không gian phân vùng đầu vào.",
		"right": null
	},
	{
		"question": "Kiểm tra tính {{đầy đủ}} là xác định các khối trong từng đặc tính đã che phủ toàn bộ miền đặc tính.",
		"right": null
	},
	{
		"question": "Kiểm tra tính {{không giao nhau}} là xác định không có giá trị nào nằm trong nhiều hơn một khối.",
		"right": null
	},
	{
		"question": "Đâu không phải cách chọn tổ hợp giá trị sinh ra từ cách chọn bao phủ t-Wise (t-Wise Coverage: TWC)?",
		"right": "Bao phủ lựa chọn cơ sở (Base Choice Coverage)."
	},
	{
		"question": "Đâu không phải đặc điểm của lựa chọn cơ sở (Base Choice)",
		"right": "Phức tạp."
	},
	{
		"question": "Khẳng định nào đúng khi nói về tiêu chí lựa chọn miền bao phủ?",
		"right": "Là chọn một giá trị từ một khối của mỗi đặc điểm cần được sử dụng ít nhất trong một ca kiểm thử."
	},
	{
		"question": "Kiểm thử cặp đôi (pair-wise) là một cách tiếp cận kiểm thử được sử dụng để kiểm thử phần mềm bằng cách sử dụng {{phương pháp tổ hợp}}.",
		"right": null
	},
	{
		"question": "Mục đích của kỹ thuật kiểm thử cặp đôi (pair-wise) là:",
		"right": "Tạo ra bộ dữ liệu có kích thước nhỏ, có thể bao phủ được nhiều lỗi nhất có thể."
	},
	{
		"question": "Tiêu chí {{bao phủ thông minh theo cặp}} là một giá trị từ mỗi khối của từng đặc điểm cần được kết hợp với với giá trị từ các khối của các đặc điểm khác.",
		"right": null
	},
	{
		"question": "Cách các ràng buộc được xử lí khi lựa chọn các giá trị phụ thuộc vào {{tiêu chí bao phủ}} được lựa chọn, và quyết định thường được đưa ra khi lựa chọn các giá trị.",
		"right": null
	},
	{
		"question": "Nếu mô hình miền đầu vào có quá nhiều ràng buộc, có khả năng nó có vấn đề về cấu trúc và phải được {{thiết kế lại}}.",
		"right": null
	},
	{
		"question": "Phương pháp nào kết hợp ngữ nghĩa với mẫu miền đầu vào?",
		"right": "Dựa vào chức năng."
	},
	{
		"question": "Tiêu chí bao phủ nào dưới đây không loại bỏ các cặp không khả thi?",
		"right": "BCC."
	},
	{
		"question": "Biểu thức (p ^ q) ^ r tương đương với biểu thức nào sau đây?",
		"right": "p ^ (q ^ r)."
	},
	{
		"question": "Đâu là luật trội trong logic mệnh đề?",
		"right": "p v T <=> T."
	},
	{
		"question": "Đồ thị dòng điều khiển là gì?",
		"right": "Là một đồ thị có hướng gồm các đỉnh tương ứng với câu lệnh\\/nhóm câu lệnh và các cạnh là các dòng điều khiển giữa các câu lệnh\\/nhóm câu lệnh."
	},
	{
		"question": "Máy hữu hạn trạng thái được áp dụng chủ yếu cho loại kiểm thử nào sau đây?",
		"right": "Kiểm thử theo mô hình"
	},
	{
		"question": "Mô hình “V” là gì?",
		"right": "Mô hình SDLC."
	},
	{
		"question": "Một nút nhánh (branching node) là",
		"right": "Một nút là điểm đi của nhiều đường dẫn (outlink)"
	},
	{
		"question": "Phát biểu \"Toán học là khó\" có được xem là một mệnh đề không?",
		"right": "Có."
	},
	{
		"question": "Yêu tố nào mà một đường đi (path) không bắt buộc phải có?",
		"right": "Phân đoạn (segment)"
	},
	{
		"question": "Cạnh của đồ thị đi từ nút ni sang nút nj và được viết là (ni, nj). ni được gọi là {{nút tiền nhiệm}}, còn nj được gọi là {{nút thừa kế}}.",
		"right": null
	},
	{
		"question": "Chiều dài của đường dẫn có một nút là bao nhiêu?",
		"right": 0
	},
	{
		"question": "Chiều dài của một đường dẫn được định nghĩa là số {{cạnh}} mà nó chứa.",
		"right": null
	},
	{
		"question": "Cho tập đường dẫn sau: Path [1, 2,4, 5, 7]. Hỏi các tập nào sau đây chứa các cạnh được thăm (edge visted) đầy đủ nhất của đường dẫn trên?",
		"right": "[1,2], [2,4], [4,5], [5,7]."
	},
	{
		"question": "Cho tập đường dẫn sau: Path [1, 2,4, 5, 7]. Hỏi các tập nào sau đây chứa các điểm được thăm (node visted) đầy đủ nhất của đường dẫn trên?",
		"right": "1, 2, 4, 5, 7."
	},
	{
		"question": "Có những mối quan hệ gì giữa các đường đi kiểm thử con được trích trong đường đi kiểm thử (Test Paths)?",
		"right": "Nhiều-cho-một (many-to-one): nhiều đường đi kiểm thử con được trích trong đường đi kiểm thử, nhiều-cho-nhiều (Many-to-many): các đường đi kiểm thử con được trích từ một hoặc nhiều các đường đi kiểm thử."
	},
	{
		"question": "Đâu là định nghĩa đúng về cặp DU(x,y) (DU Pairs)?",
		"right": "Là một cặp vị trí x, y sao cho biến v được định nghĩa (cấp phát bộ nhớ) tại x và được sử dụng tại y"
	},
	{
		"question": "Đồ thị {{Một vào, một ra (SESE)}} là đồ thị mà tất cả đường kiểm thử bắt đầu tại một nút duy nhất và kết thúc tại một nút khác cũng duy nhất.",
		"right": null
	},
	{
		"question": "Đường dẫn nào dưới đây là một chu kì (cycle)?",
		"right": "[2,5,9,6,2]"
	},
	{
		"question": "Mỗi ca kiểm thử thực thi bao nhiêu đường thi hành?",
		"right": 1
	},
	{
		"question": "Một đồ thị được mô tả như sau: N = {1, 2, 3, 4, 5, 6}; N0 = {1, 2}; Nf = {5, 6}; E = {(1, 3), (2, 3), (3, 5), (5, 4), (4, 2), (3, 6)}. Đâu là một đường dẫn khả thi đối với đồ thị trên?",
		"right": "[1, 3, 6]"
	},
	{
		"question": "Một đồ thị được mô tả như sau: N = {1, 2, 3, 4, 5, 6}; N0 = {1, 2}; Nf = {5, 6}; E = {(1, 3), (2, 3), (3, 5), (5, 4), (4, 2), (3, 6)}. Có bao nhiêu test path (đường dẫn kiểm thử) cho đồ thị trên?",
		"right": "Vô số vì bất kì đường dẫn nào đi qua vòng lặp [2, 3, 5, 4] đều kéo dài vô hạn."
	},
	{
		"question": "{{Đường đi vòng}} là một đường đi chính bắt đầu và kết thúc cùng một nút.",
		"right": null
	},
	{
		"question": "Các {{yêu cầu kiểm thử}} mô tả các thuộc tính của các đường kiểm thử.",
		"right": null
	},
	{
		"question": "Các quy tắc xác định yêu cầu kiểm tra gọi là gì?",
		"right": "Tiêu chí kiểm thử"
	},
	{
		"question": "Cái gì được xác định trên biểu đồ chỉ theo các nút và cạnh?",
		"right": "Tiêu chí về độ phù hợp của cấu trúc"
	},
	{
		"question": "Cái gì yêu cầu đồ thị được ghi chú với các tham chiếu đến các biến?",
		"right": "Tiêu chí về độ phù hợp của luồng dữ liệu"
	},
	{
		"question": "Định nghĩa thế nào là gặp gỡ (visit) trong đồ thị?",
		"right": "1 đường dẫn kiểm tra (test path) p được gọi là gặp (visit) nút n nếu n ở trên p."
	},
	{
		"question": "Mô tả thuộc tính của đường kiểm thử gọi là gì?",
		"right": "Yêu cầu kiểm thử"
	},
	{
		"question": "Một đồ thị được mô tả như sau:N = {1, 2, 3, 4}; N0 = {1}; Nf = {4}; E = {(1, 2), (2, 3), (3, 2), (2, 4)}. Liệt kê các đường dẫn đạt được Độ phủ cạnh, nhưng không đạt được Độ phủ cặp cạnh.",
		"right": "[1, 2, 3, 2, 4]."
	},
	{
		"question": "Một đồ thị được mô tả như sau:N = {1, 2, 3, 4}; N0 = {1}; Nf = {4}; E = {(1, 2), (2, 3), (3, 2), (2, 4)}. Liệt kê các đường dẫn thử nghiệm đạt được Độ phủ nút, nhưng không đạt được Độ phủ cạnh.",
		"right": "Không thể, vì bất kì đường dẫn nào truy cập nút 3 cũng truy cập cạnh (2, 3) và cạnh (3, 2)."
	},
	{
		"question": "Một đồ thị được mô tả như sau:N = {1, 2, 3, 4}; N0 = {1}; Nf = {4}; E = {(1, 2), (2, 3), (3, 2), (2, 4)}. Liệt kê tất cả các đường dẫn thử nghiệm đạt được Độ phủ cặp cạnh.",
		"right": "[1, 2, 4], [1, 2, 3, 2, 3, 2, 4]."
	},
	{
		"question": "Số đường đi nếu một đồ thị chứa vòng lặp?",
		"right": "Vô số"
	},
	{
		"question": "Số tiêu chí cho đường đi du lịch DU (Touring DU-Paths)?",
		"right": 3
	},
	{
		"question": "Thế nào là đường dẫn (path) ở trong đồ thị?",
		"right": "Đường dẫn là chuỗi các nút (node)."
	},
	{
		"question": "Thế nào là đường dẫn kiểm tra (test path)?",
		"right": "Phải là 1 đường dẫn và phải bắt đầu ở nút bắt đầu (initial node) và kết thúc ở nút kết thúc (final node)."
	},
	{
		"question": "Từ viết tắt TR biểu thị cho gì? Và định nghĩa TR là gì?",
		"right": "TR là test requirements. TR miêu tả các thuộc tính của đường dẫn kiểm tra (test path)."
	},
	{
		"question": "Bao phủ nào mà yêu cầu kiểm thử chứa mỗi đường đi có thể tới được với độ dài lên tới hai trong đồ thị?",
		"right": "Bao phủ cặp cạnh."
	},
	{
		"question": "Bao phủ nào mà yêu cầu kiểm thử chứa tất cả các đường đi trong đồ thị?",
		"right": "Bao phủ tất cả đường đi."
	},
	{
		"question": "Đâu không phải là tên khác của kiểm thử kiến trúc?",
		"right": "Kiểm thử hành vi."
	},
	{
		"question": "Đâu là một đường đi đơn giản?",
		"right": "[1,4,2,6,3,1]"
	},
	{
		"question": "Đồ thị chỉ có một nút thì có mấy cạnh?",
		"right": 0
	},
	{
		"question": "Một đồ thị có một vòng lặp thì có bao nhiêu đường đi?",
		"right": "Vô hạn."
	},
	{
		"question": "Ta có đường kiểm thử sau: [1, 2, 4, 5, 7]. Hỏi trong các tập sau đây, tập nào là thăm quan đường dẫn phụ đầy đủ nhất?",
		"right": "[1,2,4], [2,4,5], [4,5,7], [1,2,4,5], [2,4,5,7], [1,2,4,5,7]"
	},
	{
		"question": "Tiêu chí bao phủ dòng dữ liệu (Data Flow Coverage Criteria) yêu cầu đồ thị có tính chất gì?",
		"right": "Đồ thị được chú thích với các tham chiếu đến các biến"
	},
	{
		"question": "Tiêu chí kết cấu độ bao phủ (Structural coverage criteria) được định nghĩa với loại đồ thị nào?",
		"right": "Đồ thị chỉ có các cạnh và nút"
	},
	{
		"question": "Tổ chức có thể có kiểm tra nội bộ, sự tham gia trực tiếp của người dùng và phát hành phiên bản beta rất ít và nó cũng bao gồm khả năng sử dụng, khả năng tương thích, sự chấp nhận của người dùng, v.v. được gọi là",
		"right": "Kiểm thử."
	},
	{
		"question": "{{Đi qua (Tour)}}: là một đường kiểm thử p đi qua đường con q nếu q là đường con của p.",
		"right": null
	},
	{
		"question": "{{Đường đi khứ hồi}}: là một đường đi chính bắt đầu và kết thúc tại cùng một nút.",
		"right": null
	},
	{
		"question": "Đâu không phải là một trường hợp của đường p đi qua đường con q?",
		"right": "Đi qua theo vòng lặp (Tour with loops)."
	},
	{
		"question": "Đường dẫn đơn giản mà không xuất hiện như một đường dẫn con thích hợp của bất kì đường dẫn đơn giản nào khác là gì",
		"right": "Đường dẫn chính"
	},
	{
		"question": "Đường dẫn kiểm thử p đi qua đường dẫn con q nếu q là một đường dẫn con của p là gì?",
		"right": "Chuyến đi (tour)"
	},
	{
		"question": "Đường dẫn kiểm thử p đi qua đường dẫn con q với các đường phụ nếu và chỉ nếu mọi nút trong q cũng theo thứ tự p là gì?",
		"right": "Đi theo đường vòng"
	},
	{
		"question": "Đường đi khứ hồi (Round-trip path) là gì?",
		"right": "Là một đường đi chính bắt đầu và kết thúc ở cùng một nút"
	},
	{
		"question": "Khái niệm {{def}} là một vị trí mà ở đó giá trị một biến được lưu vào bộ nhớ.",
		"right": null
	},
	{
		"question": "Khái niệm {{use}} là một vị trí mà giá trị của biến được truy cập.",
		"right": null
	},
	{
		"question": "Sự định nghĩa (definition - def) là gì?",
		"right": "Là địa chỉ mà giá trị của một biến được lưu trữ trong bộ nhớ"
	},
	{
		"question": "Sự sử dụng (use) là gì?",
		"right": "Là vị trí mà giá trị của một biến được truy cập (được gọi)"
	},
	{
		"question": "Ý nào sau đây không đúng khi nói về tiêu chuẩn bao phủ luồng dữ liệu phổ biến nhất?",
		"right": "Bao phủ đường đi."
	},
	{
		"question": "Đâu là định nghĩa đúng về (use)?",
		"right": "Là vị trí mà giá trị của một biến được truy cập (hoặc là sử dụng)"
	},
	{
		"question": "Bao phủ dòng lệnh được xác định như thế nào?",
		"right": "Số dòng lệnh khả thi trong ca kiểm thử chia cho tổng số dòng lệnh."
	},
	{
		"question": "Nếu bạn đang kiểm thử 1 module code, làm thế nào để biết được mức độ bao phủ quyết định đã đạt được?",
		"right": "Bằng cách lấy số đầu ra đã kiểm thử chia cho tổng số đầu ra quyết định trong module."
	},
	{
		"question": "\\/\\/if (x < y){\r\ny = 0;\r\nx = x + 1;}\r\n\\/\\/\r\nCần bao nhiêu đỉnh để mô hình đoạn chương trình trên bằng đồ thị luồng điều khiển (Control Flow Graph)?",
		"right": 3
	},
	{
		"question": "\\/\\/if (x < y){\r\ny = 0;\r\nx = x + 1;}\r\n\\/\\/\r\nKhông thể mô hình đoạn mã trên thành khối {{cơ bản}} vì đồ thị luồng điều khiển có chứa nhánh (branch).",
		"right": null
	},
	{
		"question": "Đâu không phải là trường hợp của việc định nghĩa (def) cho một biến x?",
		"right": "Biến x xuất hiện bên phải phép gán (assignment)."
	},
	{
		"question": "Đâu là đồ thị được sử dụng phổ biến nhất cho việc kiểm thử thiết kế kiến trúc.",
		"right": "Đồ thị gọi (Call graph)."
	},
	{
		"question": "Trong đồ thị luồng điều khiển (call graph), một cạnh (edge) mô tả điều gì?",
		"right": "Cách gọi tới một đơn vị (unit)."
	},
	{
		"question": "Trong đồ thị luồng điều khiển (call graph), một nút (node) tượng trưng cho yếu tố nào?",
		"right": "Một đơn vị (Unit)."
	},
	{
		"question": "Kiểm tra tĩnh (không được coi là kiểm tra truyền thống) tiến hành bằng cách {{kiểm tra từng ràng buộc}}.",
		"right": null
	},
	{
		"question": "Máy hữu hạn trạng thái (FSM - Finite State Machine) có thể được chú thích với nhiều kiểu hành động khác nhau. Nhưng không là hành động nào trong số các hành động sau:",
		"right": "Vị trí của các nút (Position of nodes)."
	},
	{
		"question": "Ràng buộc tuần tự (Sequencing Constraints) là {{các quy tắc || rules}} áp đặt các ràng buộc về thứ tự mà các phương thức có thể gọi được.",
		"right": null
	},
	{
		"question": "Đâu không phải là thước đo để dừng kiểm thử?",
		"right": "Số người đã kiểm thử"
	},
	{
		"question": "Phát biểu nào về ràng buộc trình tự là đúng?",
		"right": "Ràng buộc trình tự nắm bắt được tất cả các hành vi."
	},
	{
		"question": "Ràng buộc trình tự có thể được mã hóa trở thành gì?",
		"right": "Các tiền điều kiện hoặc các thông số kĩ thuật khác."
	},
	{
		"question": "Các biến được xác định ở cấp {{mô hình thiết kế}} và có thể không nhất thiết phải tương ứng với các biến trong một triển khai.",
		"right": null
	},
	{
		"question": "FSM thường xác định các điều kiện tiên quyết hoặc bảo vệ khi chuyển đổi, xác định các giá trị mà các biến cụ thể phải có để quá trình chuyển đổi kích hoạt các {{sự kiện(events)}}.",
		"right": null
	},
	{
		"question": "Khi các biến thay đổi, phần mềm được coi là chuyển từ trạng thái trước của quá trình {{tiền nhiệm}} sang trạng thái kế nhiệm.",
		"right": null
	},
	{
		"question": "Khi các biến thay đổi, phần mềm được coi là chuyển từ trạng thái trước của quá trình tiền nhiệm sang trạng thái {{kế nhiệm}}.",
		"right": null
	},
	{
		"question": "Máy trạng thái hữu hạn không thể được chú thích bằng loại hành động nào?",
		"right": "Hành động sửa đổi phương thức."
	},
	{
		"question": "Máy trạng thái hữu hạn là một đồ thị có các nút đại diện cho các trạng thái trong hành vi thực thi của phần mềm và các cạnh biểu thị sự {{chuyển đổi giữa các trạng thái}}.",
		"right": null
	},
	{
		"question": "Nếu trạng thái trước và trạng thái sau của quá trình chuyển đổi giống nhau, thì giá trị của các biến trạng thái sẽ {{không thay đổi}}.",
		"right": null
	},
	{
		"question": "Phương pháp chính khác để sử dụng đồ thị dựa trên thông số kỹ thuật là mô hình hóa hành vi trạng thái của phần mềm bằng cách phát triển một số dạng {{máy trạng thái hữu hạn}}.",
		"right": null
	},
	{
		"question": "Trong hầu hết các công thức của FSM, các nút không được phép có định nghĩa hoặc sử dụng các {{biến (state)}.",
		"right": null
	},
	{
		"question": "Trong máy trạng thái hữu hạn, một cạnh (edge) mô tả điều gì?",
		"right": "Việc chuyển đổi trạng thái (transitions)."
	},
	{
		"question": "Trong máy trạng thái hữu hạn, một nút (node) tượng trưng cho yếu tố nào?",
		"right": "Một trạng thái (state)."
	},
	{
		"question": "Yếu tố nào sau đây không xác định máy hữu hạn trạng thái?",
		"right": "Danh sách ca kiểm thử."
	},
	{
		"question": "Ngôn ngữ mô hình hóa thống nhất các trường hợp sử dụng (UML use case) thường được dùng để diễn đạt gì?",
		"right": "Yêu cầu phần mềm (Software requirements)."
	},
	{
		"question": "{{Đơn tử || (literal)}} là một mệnh đề đơn, hoặc là phủ định của một mệnh đề đơn.",
		"right": null
	},
	{
		"question": "{{Một hạn từ con||subterm}}thích hợp là một hạn từ (term) trong đó có một hoặc nhiều mệnh đề bị loại bỏ.",
		"right": null
	},
	{
		"question": "{{Quá tải||Overloading}} sử dụng cùng một tên cho các hàm tạo hoặc phương thức khác nhau trong cùng một lớp.",
		"right": null
	},
	{
		"question": "Có bao nhiêu mệnh đề đúng cho vị ngữ dưới đây? (G ∨ ((m > a) ∨ (s <= o + n)) ∧ U)",
		"right": 4
	},
	{
		"question": "Đâu không phải là 1 trong các nguồn của vị từ?",
		"right": "Quyết định bên ngoài các chương trình."
	},
	{
		"question": "Đâu không phải là một dạng của bao phủ logic?",
		"right": "Bao phủ cực (Pole Coverage)"
	},
	{
		"question": "Đâu không phải là một phương pháp kiểm thử?",
		"right": "Kiểm thử hộp bạc (Silver box testing)"
	},
	{
		"question": "Đâu là các mệnh đề trong vị từ sau đây: ((A V B) ∧ (C V D)) → E?",
		"right": "A, B, C, D, E"
	},
	{
		"question": "Loại Kiểm tra nào sau đây giả định rằng một đường dẫn logic trong một đơn vị hoặc chương trình đã được biết trước?",
		"right": "Kiểm thử hộp trắng"
	},
	{
		"question": "Một dự đoán không thể chứa loại nào sau đây?",
		"right": "Biến phi luận lý có chứa giá trị nguyên"
	},
	{
		"question": "Một dự đoán thường có {{ 3 }} mệnh đề",
		"right": null
	},
	{
		"question": "Trong một phần mềm, biểu thức logic không đến từ nguồn nào trong các nguồn sau đây?",
		"right": "Các cách đặt tên biến."
	},
	{
		"question": "Ý nào sau đây đúng về định nghĩa hạng thức (term)?",
		"right": "Hạng thức (term): là một tập hợp các đơn tử được kết nối với nhau bằng logic \"và\" (\"and\")."
	},
	{
		"question": "Bao phủ kết hợp (Combination coverage) trở nên không thực tế khi bao gồm bao nhiêu mệnh đề?",
		"right": "Nhiều hơn 3 hoặc 4."
	},
	{
		"question": "Bao phủ mệnh đề (Clause coverage) không phụ thuộc vào bao phủ {{dự đoán}}.",
		"right": null
	},
	{
		"question": "Biểu thức logic không đến từ nguồn nào sau đây?",
		"right": "Hệ điều hành"
	},
	{
		"question": "Cách đơn giản nhất để có được bao hàm thuộc tính và mệnh đề là gì?",
		"right": "Kiểm thử mọi kết hợp của hai loại bao hàm."
	},
	{
		"question": "Cho vị ngữ ((f <= g) ∧ (X > 0)) ∨ (M ∧ (e < d + c)). Có bao nhiêu mệnh đề trong vị ngữ trên?",
		"right": 4
	},
	{
		"question": "Cho vị ngữ ((f <= g) ∧ (X > 0)) ∨ (M ∧ (e < d + c)). Đâu không phải mệnh đề của vị ngữ trên?",
		"right": "X"
	},
	{
		"question": "Đâu không phải là một trong bốn cấu trúc của chương trình tạo mẫu?",
		"right": "Không gian đầu ra."
	},
	{
		"question": "Hầu hết các vị ngữ thường có bao nhiêu mệnh đề?",
		"right": 1
	},
	{
		"question": "Nếu chỉ có một mệnh đề thì nên sử dụng bao phủ nào?",
		"right": "PC"
	},
	{
		"question": "Ta có phép toán sau: ((a < b) ∨ D) ∧ (m >= n*o). Với các giá trị cho trước: m = 1, n = 1, o =1, các giá trị nào của a, b, D thì cho phép vị từ trên là đúng?",
		"right": "a = 5, b =10, D = true"
	},
	{
		"question": "Bao phủ vị từ (Predicate Coverage) tương đương với loại bao phủ nào?",
		"right": "Bao phủ cạnh (Edge Coverage)."
	},
	{
		"question": "Biểu thức đánh giá giá trị nhị phân (đúng\\/sai) gọi là gì?",
		"right": "Vị từ"
	},
	{
		"question": "Ta có các phép toán tử sau: ¬, ∧ , ∨, ↔, đâu là phép toán tử tương đương?",
		"right": "↔"
	},
	{
		"question": "Tiêu chuẩn mà xét các trường hợp từng mệnh đề với hai giá trị True và False là tiêu chuẩn nào?",
		"right": "Bao phủ mệnh đề."
	},
	{
		"question": "Toán tử A {{XOR}} B cho kết quả 1 (true) nếu A và B khác chân trị, 0 (false) nếu A và B cùng chân trị.",
		"right": null
	},
	{
		"question": "Bao phủ nào bắt buộc cj(ci = true) != \r\ncj(ci = false)?",
		"right": "RACC"
	},
	{
		"question": "Bao phủ nào bắt buộc p(ci = true) != \r\np(ci = false)?",
		"right": "CACC"
	},
	{
		"question": "Bao phủ nào mà các giá trị được chọn \r\ncho các mệnh đề phụ cj không cần phải giống nhau khi ci = true hay ci = false?",
		"right": "GACC"
	},
	{
		"question": "Có thể thỏa mãn loại bao phủ nào mà \r\nkhông cần thỏa mãn bao phủ vị từ?",
		"right": "GACC"
	},
	{
		"question": "{{Bao phủ mệnh đề không hoạt động || Inactive Clause Coverage}} là bao phủ mà các mệnh đề chính không ảnh hưởng đến các vị ngữ.",
		"right": null
	},
	{
		"question": "Bao phủ mệnh đề hoạt động có giới hạn (Restricted Active Clause Coverage) không bao hàm (subsume) bao phủ nào sau đây?",
		"right": "Bao phủ mệnh đề không hoạt động có giới hạn (Restricted Inactive Clause Coverage)."
	},
	{
		"question": "Ta có phép vị từ sau: (a > b ∧ b > c) ∨ c > a.\r\nVới các cặp giá trị nào sau đây thì phép vị từ trên là bất khả thi?",
		"right": "(a > b) = true, (b > c) = true, (c > a) = true"
	},
	{
		"question": "Biểu thức nào sau đây là dạng chuẩn tắc tuyển?",
		"right": "abc + de"
	},
	{
		"question": "Một biểu thức (term) là gì?",
		"right": "Là một tập các giá trị (literal) được liên kết với nhau bởi phép \"and\""
	},
	{
		"question": "Một biểu thức chuẩn tắc tuyển (predicate) là gì?",
		"right": "Là một tập các giá trị (literal) được liên kết với nhau bởi phép \"or\""
	},
	{
		"question": "Một giá trị (literal) là gì?",
		"right": "Là một mệnh đề hoặc phủ định của một mệnh đề. Vd: a, not a"
	},
	{
		"question": "{{Hàm ý nguyên tố}} là một hàm ý mà các phần con trong nó không phải là hàm ý.",
		"right": null
	},
	{
		"question": "Một điểm đúng độc nhất tương ứng với một hàm ý cho trước là sự gán giá trị thực sao cho:",
		"right": "Giá trị của hàm ý đã cho là true và các hàm ý khác là false."
	},
	{
		"question": "{{Hàm ý chính}} là một hàm ý sao cho không có thuật ngữ phụ thích hợp cũng là một hàm ý.",
		"right": null
	},
	{
		"question": "{{Hàm ý thừa}} là hàm ý có thể được loại bỏ mà không làm thay đổi giá trị của vị từ.",
		"right": null
	},
	{
		"question": "{{Thuật ngữ con thích hợp}} là một thuật ngữ có một hoặc nhiều mệnh đề bị loại bỏ.",
		"right": null
	},
	{
		"question": "Đại diện chỉ có hàm ý nguyên tố, không dư thừa là gì?",
		"right": "Đại diện DNF tối thiểu"
	},
	{
		"question": "Đâu không phải thuật ngữ con thích hợp của \"abc\"?",
		"right": "abc"
	},
	{
		"question": "Hàm ý có thể được loại bỏ mà không làm thay đổi giá trị của vị từ là gì?",
		"right": "Hàm ý thừa"
	},
	{
		"question": "Hàm ý mà không có thuật ngữ con thích hợp cũng là một hàm ý là gì?",
		"right": "Hàm ý chính"
	},
	{
		"question": "Hàm ý nào có thể được loại bỏ mà không làm thay đổi giá trị của vị từ?",
		"right": "Hàm ý dư thừa (Redundant Implicant)."
	},
	{
		"question": "Một thể hiện DNF tối giản là một thể hiện với các yếu tố nào?",
		"right": "Hàm ý nguyên tố không thừa thãi"
	},
	{
		"question": "Thuật ngữ có một hoặc nhiều mệnh đề bị loại bỏ là gì?",
		"right": "Hàm ý chính"
	},
	{
		"question": "Trong tiêu chuẩn bao phủ MUMCUT ta không áp dụng tiêu chuẩn nào sau đây?",
		"right": "Bao phủ tổ hợp."
	},
	{
		"question": "Bao phủ ACC chỉ có tác dụng với vị ngữ gồm bao nhiêu mệnh đề?",
		"right": "3 hoặc nhiều hơn."
	},
	{
		"question": "Các biến vị ngữ không phải là đầu vào được gọi là gì?",
		"right": "Biến nội hàm."
	},
	{
		"question": "Đâu là định nghĩa đúng khi nói về biến nội bộ (internal variable)?",
		"right": "Là những biến nằm trong vị từ không thuộc giá trị đầu vào."
	},
	{
		"question": "Mệnh đề sau liên quan đến kiểm thử quyết định: \"Khi code chỉ chứa 1 lệnh if và không có vòng lặp hay lệnh CASE, mọi test case đơn lẻ sẽ cho kết quả 50% độ bao phủ quyết định.\" Câu nào dưới đây là đúng?",
		"right": "Câu trên đúng. Mọi ca kiểm thử riêng lẻ có thể cho đầu ra của lệnh `if` là cả true hoặc false."
	},
	{
		"question": "Nếu một biến đầu vào được thay đổi trong một phương thức, thì sau đó nó được coi là {{một biến nội bộ}}.",
		"right": null
	},
	{
		"question": "Việc tạo văn phạm (grammar) từ không gian đầu vào có thể phát hiện lỗi được không?",
		"right": "Có."
	},
	{
		"question": "Biến vị từ (predicate) không thể được sinh ra từ lệnh (statement) nào?",
		"right": "return"
	},
	{
		"question": "Nếu mà một thuộc tính chỉ có một mệnh đề thì bao hàm nào không chuyển thành PC?",
		"right": "ICC"
	},
	{
		"question": "Bao phủ logic không mô tả hành vi ở mức độ (level) nào?",
		"right": "Các phép toán (Operators)."
	},
	{
		"question": "Các tiền điều kiện (preconditions) nên được đặt ở đâu?",
		"right": "Ở trong các bình luận trên đầu phương thức."
	},
	{
		"question": "Chọn câu trả lời đúng nhất về tính trang trọng (formal) của đặc tả.",
		"right": "Đặc tả có thể trang trọng (formal) hoặc không trang trọng (informal)."
	},
	{
		"question": "Đặc tả chính thức được viết dưới dạng gì?",
		"right": "Biểu diễn toán học"
	},
	{
		"question": "Đặc tả được viết bằng ngôn ngữ tự nhiên cần phải làm gì trước khi thiết kế ca kiểm thử?",
		"right": "Chuyển về dạng biểu thức logic."
	},
	{
		"question": "Đặc tả không chính thức được viết dưới dạng gì?",
		"right": "Ngôn ngữ tự nhiên."
	},
	{
		"question": "Một vị từ ở dạng chuẩn tắc tuyển (DNF) nếu nó bao gồm các mệnh đề hoặc liên từ được nối bởi toán tử gì?",
		"right": "Hoặc (Or)."
	},
	{
		"question": "Một vị từ ở dạng hội chuẩn CNF nếu nó bao gồm các mệnh đề hoặc liên từ được nối bởi toán tử gì?",
		"right": "Và (And)."
	},
	{
		"question": "Chọn câu trả lời đúng nhất về đồ thị FSMs.",
		"right": "Đồ thị FSMs được sử dụng rộng rãi trong tất cả các cấp (level) của trừu tượng (abstraction)"
	},
	{
		"question": "Đâu không là cách tốt nhất để kiểm thử máy hữu hạn trạng thái (FSM)?",
		"right": "Xây dựng các trạng thái độc lập"
	},
	{
		"question": "Đồ thị FSMs là đồ thị mà.",
		"right": "Nút biểu diễn trạng thái (state), cạnh biểu diễn sự thay đổi giữa các trạng thái"
	},
	{
		"question": "Khẳng định nào đúng nhất về đồ thị SESE?",
		"right": "Là đồ thị có tất cả các đường đi đều bắt đầu tại một điểm đơn và cũng kết thúc tại điểm đơn."
	},
	{
		"question": "Khẳng định nào sau đây là sai về Máy trạng thái hữu hạn?",
		"right": "Chỉ có thể dùng biểu đồ trạng thái để thể hiện Máy trạng thái hữu hạn"
	},
	{
		"question": "Máy hữu hạn trạng thái (Finite State Machine - FSM) có thể được phân loại bởi?",
		"right": "Đầu vào\\/Đầu ra hoặc Trạng thái"
	},
	{
		"question": "Máy hữu hạn trạng thái (Finite State Machine - FSM) là một mô hình về hành vi bao gồm một số hữu hạn các?",
		"right": "Trạng thái (state), sự chuyển tiếp (transition) và hành động (action)"
	},
	{
		"question": "Máy trạng thái hữu hạn là đồ thị, trong đó các nút (Nodes) biểu diễn gì?",
		"right": "Các trạng thái (States)."
	},
	{
		"question": "Một hành động của máy hữu hạn trạng thái là gì?",
		"right": "Đây là một hoạt động mà được thực hiện tại một thời điểm nhất định"
	},
	{
		"question": "{{Ẩn biến}} được thực hiện bằng cách xác định một biến trong lớp con có cùng tên và kiểu của một biến kế thừa.",
		"right": null
	},
	{
		"question": "Số mục tiêu chung trong việc sử dụng cú pháp để tạo kiểm tra?",
		"right": 2
	},
	{
		"question": "Thuộc tính {{đa hình}} là một tham chiếu đối tượng có thể có nhiều kiểu khác nhau.",
		"right": null
	},
	{
		"question": "4 cấu trúc để mô hình hóa phần mềm bao gồm có cú pháp (syntax) thì ở cú pháp có tích hợp những gì?",
		"right": "Mã nguồn, đầu vào, mô hình."
	},
	{
		"question": "Bao phủ kí hiệu kết thúc (Terminal Symbol Coverage) tương đương với loại bao phủ nào?",
		"right": "Bao phủ nút (Node Coverage)."
	},
	{
		"question": "ĐỊnh nghĩa thế nào là xóa bỏ đột biến (kill mutants).",
		"right": "Cho 1 đột biến m thuộc M với nguồn gốc D và bài kiểm thử t, t được gọi là xóa bỏ m khi và chỉ khi đầu ra của t ở D là khác với đầu ra của t ở trên m."
	},
	{
		"question": "Đột biến dựa vào cái gì?",
		"right": "Đột biến dựa vào toán tử đột biến (mutation operators) và các chuỗi cơ bản (ground strings)."
	},
	{
		"question": "Mô tả cú pháp (Syntactic description) không đến từ nguồn nào sau đây?",
		"right": "Cú pháp của ngôn ngữ lập trình (Syntax)."
	},
	{
		"question": "Thế nào là bao phủ đột biến (mutation coverage)?",
		"right": "Với mỗi m thuộc M, TR chỉ chứa duy nhất 1 yêu cầu đó là xóa bỏ m."
	},
	{
		"question": "Thế nào là chuỗi cơ bản (ground strings)?",
		"right": "Chuỗi cơ bản (ground strings) là 1 chuỗi trong ngữ pháp (grammar). Thuật ngữ \"cơ bản\" (ground) được dùng như 1 phép tương tự với các thuật ngữ cơ bản của đại sô."
	},
	{
		"question": "Tiêu chí bao phủ kí tự cuối cùng (Terminal Symbol Coverage) đối với ngữ pháp tương đương với loại bao phủ nào đối với đồ thị?",
		"right": "Bao phủ nút"
	},
	{
		"question": "Tiêu chí bao phủ nào sau đây được đánh giá là không thực tế?",
		"right": "Bao phủ dẫn xuất."
	},
	{
		"question": "Xét BNF sau: A ::= O B | O M | O B M; O ::= \"w\" | \"x\" | \"s\" | \"m\"; B ::= \"i\" | \"f\" | \"c\" | \"r\"; M ::= \"o\" | \"t\" | \"p\" | \"a\" | \"h\".Có bao nhiêu kí hiệu đầu cuối cho văn phạm trên?",
		"right": 13
	},
	{
		"question": "Xét BNF sau: A ::= O B | O M | O B M; O ::= \"w\" | \"x\" | \"s\" | \"m\"; B ::= \"i\" | \"f\" | \"c\" | \"r\"; M ::= \"o\" | \"t\" | \"p\" | \"a\" | \"h\".Có bao nhiêu kí hiệu không phải đầu cuối cho văn phạm trên?",
		"right": 4
	},
	{
		"question": "Cho một biểu thức chính quy: (G s n | B t n)*. Điều nào sau đây không đúng?",
		"right": "G và B đại diện cho hai thứ khác nhau."
	},
	{
		"question": "Chọn đáp án sai trong các đáp án sau đây.",
		"right": "Ngữ pháp (Grammars)mô tả chỉ chuỗi hợp lệ ."
	},
	{
		"question": "Một chuỗi thuộc ngữ pháp được định nghĩa là gì?",
		"right": "Là chuỗi thỏa mãn các luật dẫn xuất từ ngữ pháp."
	},
	{
		"question": "Số lượng yêu cầu kiểm tra cho việc biến đổi phụ thuộc vào mấy điều?",
		"right": 2
	},
	{
		"question": "Số tiêu chí bao phủ dựa trên cú pháp?",
		"right": 2
	},
	{
		"question": "{{Toán tử đột biến (Mutation Operator)}}: là quy tắc chỉ định các biến thể cú pháp của chuỗi được tạo từ ngữ pháp.",
		"right": null
	},
	{
		"question": "Bao phủ đột biến yếu (Weak mutation coverage) không thỏa mãn tính chất nào trong mô hình RIPR?",
		"right": "Tính chạm tới (Reachability)."
	},
	{
		"question": "Bao phủ nào được định nghĩa về mặt loại bỏ đột biến?",
		"right": "Bao phủ đột biến."
	},
	{
		"question": "Các tiêu chí nào là kết quả của việc tạo ra các chuỗi không hợp lệ?",
		"right": "Bao phủ toán tử đột biến và bao phủ sản phẩm đột biến."
	},
	{
		"question": "Cho 2 chuỗi cơ sở như sau:\r\nG 26 08.01.90\r\nB 25 01.20.99\r\nĐâu là chuỗi đột biến hợp lệ?",
		"right": "B 26 08.01.90."
	},
	{
		"question": "Cho mệnh đề if (a || b), đâu không phải là đột biến?",
		"right": "if (a || b)"
	},
	{
		"question": "Chuỗi nền (ground string) là gì?",
		"right": "Chuỗi trong một ngữ pháp"
	},
	{
		"question": "Đâu không phải là một nguồn trong các mô tả cú pháp (Syntactic description)?",
		"right": "Mô tả về đầu ra"
	},
	{
		"question": "Đột biến là gì?",
		"right": "Kết quả của một ứng dụng của một toán tử biến đổi."
	},
	{
		"question": "Mô hình RIPR (Reachability, Infection, Propagation, Revealability) dẫn tới {{2}} biến thể của bao phủ đột biến.",
		"right": null
	},
	{
		"question": "Một {{đột biến}} là một biến thể của một chuỗi hợp lệ.",
		"right": null
	},
	{
		"question": "Quan hệ nào sau đây sai?",
		"right": "Bao phủ luật sản sinh bao hàm bao phủ kí tự kết thúc."
	},
	{
		"question": "Số {{bao phủ}} trong đột biến tương đương với số biến dị bị loại bỏ.",
		"right": null
	},
	{
		"question": "Trong kiểm thử đột biến, đột biến được dựa trên {{đột biến toán tử}} và chuỗi gốc (ground string).",
		"right": null
	},
	{
		"question": "Biến dị chết (Dead mutants) là gì?",
		"right": "Một trường hợp kiểm thử đã loại bỏ biến dị đó"
	},
	{
		"question": "Biến dị chết lưu (Stillborn mutants) là gì?",
		"right": "Biến dị vi phạm cú pháp"
	},
	{
		"question": "Biến dị không đáng kể (Trivial mutants) là gì?",
		"right": "Hầu như mọi ca kiểm thử đều có thể loại bỏ biến dị này."
	},
	{
		"question": "Biến dị tương đương (Equivalent mutants)",
		"right": "Không ca kiểm thử nào có thể loại bỏ biến di này"
	},
	{
		"question": "Cho ví dụ sau: if (X <= Y && a > 0).\r\nHỏi đâu là phép toán tử thay thế điều kiện (COR) đúng?",
		"right": "if (X <= Y || a > 0)"
	},
	{
		"question": "Đột biến chết (dead mutant) là gì?",
		"right": "Là đột biến bị ít nhất một ca kiểm thử tiêu diệt."
	},
	{
		"question": "Dữ liệu kiểm thử có thể tiếp cận tới các câu lệnh sai (trong kiểm thử đột biến – câu lệnh đột biến) là khả năng gì trong mô hình RIPR?",
		"right": "Khả năng chạm tới"
	},
	{
		"question": "Kiểm thử đột biến được sử dụng rộng rãi cho loại kiểm thử nào?",
		"right": "Kiểm thử đơn vị (Unit Testing)"
	},
	{
		"question": "Một loại đột biến có thể chỉ cần một ca kiểm thử để có thể loại bỏ được nó là:",
		"right": "Đột biến chết (Dead Mutants)"
	},
	{
		"question": "Tiêu chí BNF được sử dụng để kiểm thử _____.",
		"right": "Chương trình dịch (Compiler)"
	},
	{
		"question": "Các phép toán chỉnh sửa chuỗi nền (ground strings) để tạo ra cái gì?",
		"right": "Các chương trình đột biến."
	},
	{
		"question": "Cho các phép toán tử đột biến sau đây: minval = B, if(B > A), Bomb(), minVal = failOnZero (B), đâu là phép thay thế toán tử quan hệ?",
		"right": "if(B > A)."
	},
	{
		"question": "Định nghĩa đột biến chết (dead mutant) là gì?",
		"right": "Một trường hợp thử nghiệm đã giết chết nó."
	},
	{
		"question": "Định nghĩa đột biến tầm thường (trivial mutant) là gì?",
		"right": "Hầu hết mọi thử nghiệm đều có thể giết chết nó."
	},
	{
		"question": "Tiêu chí nào được sử dụng nhiều nhất để kiểm tra trình biên dịch?",
		"right": "Tiêu chí BNF."
	},
	{
		"question": "ABS là viết tắt của toán tử đột biến nào?",
		"right": "Chèn giá trị tuyệt đối."
	},
	{
		"question": "AOR là viết tắt của toán tử đột biến nào?",
		"right": "Thay thế toán tử số \r\nhọc."
	},
	{
		"question": "ASR là viết tắt của toán tử đột biến nào?",
		"right": "Thay thế toán tử gán."
	},
	{
		"question": "Các toán tử sẽ điều chỉnh một chuỗi cơ sở (chương trình dưới ca kiểm thử) để tạo ra các {{chương trình biến dị}}.",
		"right": null
	},
	{
		"question": "COR là viết tắt của toán tử đột biến nào?",
		"right": "Thay thế toán tử điều kiện."
	},
	{
		"question": "Đâu là viết tắt của toán tử đột biến chèn giá trị tuyệt đối?",
		"right": "ABS."
	},
	{
		"question": "Kiểm thử đột biến được sử dụng chủ yếu vào việc gì?",
		"right": "Kiểm thử đơn vị và kiểm thử tích hợp các lớp."
	},
	{
		"question": "Loại bỏ đột biến yếu không thỏa mãn yếu tố gì trong mô hình RIPR?",
		"right": "Lan truyền (Propagation)."
	},
	{
		"question": "ROR là viết tắt của toán tử đột biến \r\nnào?",
		"right": "Thay thế toán tử quan hệ."
	},
	{
		"question": "SVR là viết tắt của {{thay thế biến vô hướng}}.",
		"right": null
	},
	{
		"question": "Tại mức phương thức, các toán tử đột biến cho các ngôn ngữ lập trình khác nhau là {{giống nhau}}.",
		"right": null
	},
	{
		"question": "Trong tiến trình kiểm thử chương trình với đột biến, ở bước kiểm tra đạt ngưỡng (threshold reached?), nếu chưa đạt ngưỡng thì ta quay lại bước nào sau đây?",
		"right": "Tạo các ca kiểm thử."
	},
	{
		"question": "UOD là viết tắt của {{xóa toán tử đơn ngôi}}.",
		"right": null
	},
	{
		"question": "UOI là viết tắt của {{chèn toán tử đơn ngôi}}.",
		"right": null
	},
	{
		"question": "\\/\\/MyObject a, b;\r\n. . . \r\ncallMethod (a);\r\nΔ callMethod (b);\\/\\/\r\nVí dụ trên thuộc kiểu toán tử đột biến tích hợp nào?",
		"right": "Thay thế biến tham số tích hợp (IPVR)."
	},
	{
		"question": "\\/\\/int myMethod ()\r\n{\r\nreturn a + b;\r\nreturn ++a + b;\r\nreturn a – b;\r\n} \\/\\/\r\nVí dụ trên thuộc kiểu toán tử đột biến tích hợp nào?",
		"right": "Sửa đổi biểu thức trả về tích hợp (IREM)."
	},
	{
		"question": "\\/\\/Max (a, b);\r\nΔ Max (b, a);\\/\\/\r\nVí dụ trên thuộc kiểu toán tử đột biến tích hợp nào?",
		"right": "Trao đổi tham số tích hợp (IPEX)."
	},
	{
		"question": "\\/\\/X = Max (a, b);\r\nΔ X = new Integer (0);\\/\\/\r\nVí dụ trên thuộc kiểu toán tử đột biến tích hợp nào?",
		"right": "Xóa cuộc gọi theo phương pháp tích hợp (IMCD)."
	},
	{
		"question": "Có mấy loại lớp toán tử đột biến dành cho Java?",
		"right": 4
	},
	{
		"question": "IMCD là viết tắt của {{Integration Method Call Deletion}}.",
		"right": null
	},
	{
		"question": "Java cung cấp bốn {{mức độ truy cập}} là private, protected, public, default.",
		"right": null
	},
	{
		"question": "Kiểm thử {{tích hợp}} là kiểm tra kết nối giữa các đơn vị chương trình riêng biệt.",
		"right": null
	},
	{
		"question": "Kiểm thử tích hợp thường dựa trên các {{khớp nối}} đó là các mối quan hệ minh bạch và ẩn tàng giữa các bộ phận của phần mềm.",
		"right": null
	},
	{
		"question": "Kiểm thử {{BNF}} chưa được sử dụng ở cấp độ tích hợp.",
		"right": null
	},
	{
		"question": "\"Mỗi biểu thức trong mỗi câu lệnh trả về trong một phương thức được sửa đổi bằng cách áp dụng các toán tử UOI và AOR.\" là định nghĩa của toán tử đột biến tích hợp nào?",
		"right": "IREM"
	},
	{
		"question": "\"Mỗi biểu thức trong phương thức gọi đều được chỉnh sửa bằng cách chèn thêm tất cả các toán tử đơn phân có thể vào trước và sau nó.\" là định nghĩa của toán tử đột biến tích hợp nào?",
		"right": "IUOI"
	},
	{
		"question": "{{Ẩn biến || variable hiding}} được thực hiện bằng cách xác định một biến trong lớp con có cùng tên và kiểu của một biến kế thừa.",
		"right": null
	},
	{
		"question": "{{Đóng gói}} là một cơ chế trừu tượng sử dụng để cài đặt che dấu thông tin, nó là một kỹ thuật thiết kế với mong muốn bảo vệ một số phần của thiết kế khỏi các phần của quá trình thực thi",
		"right": null
	},
	{
		"question": "{{Ghi đè || Override}} cho phép các lớp con xác định lại các phương thức kế thừa. Phương thức lớp con có cùng một chữ ký, những cách triển khai khác.",
		"right": null
	},
	{
		"question": "{{Nạp chồng || Overload}} cho phép một phương thức trong lớp con có cùng tên, các đối số và kiểu kết quả giống như một phương thức trong lớp cha của nó.",
		"right": null
	},
	{
		"question": "{{Nạp chồng phương thức || method overriding}} cho phép một phương thức trong lớp con có cùng tên, các đối số và kiểu kết quả giống như một phương thức trong lớp cha của nó.",
		"right": null
	},
	{
		"question": "Biến dị được coi là ca kiểm thử ở cách kiểm thử nào?",
		"right": "Kiểm thử dựa trên đầu vào (Input-base)."
	},
	{
		"question": "Có bao nhiêu loại toán tử tương tác tích hợp?",
		"right": 5
	},
	{
		"question": "Đâu không phải là cấp độ truy cập do Java cung cấp?",
		"right": "Không bảo vệ (Unprotected)."
	},
	{
		"question": "Đâu không phải toán tử đột biến hướng đối tượng thuộc lớp đa hình?",
		"right": "AMC"
	},
	{
		"question": "Đâu không phải toán tử đột biến hướng đối tượng thuộc lớp kế thừa?",
		"right": "PNC"
	},
	{
		"question": "Đột biến {{tích hợp}} xuất hiện khi có đột biến hóa sự kết nối giữa các bộ phận.",
		"right": null
	},
	{
		"question": "IPEX là viết tắt của toán tử đột biến tích hợp nào?",
		"right": "Tích hợp trao đổi tham số."
	},
	{
		"question": "IPVR là viết tắt của toán tử đột biến tích hợp nào?",
		"right": "Tích hợp thay thế biến tham số."
	},
	{
		"question": "IUOI là viết tắt của toán tử đột biến tích hợp nào?",
		"right": "Tích hợp chèn toán tử đơn phân."
	},
	{
		"question": "Java cung cấp cho chúng ta bao nhiêu mức truy cập dữ liệu?",
		"right": 4
	},
	{
		"question": "Toán tử đột biến được sử dụng ở mức độ nào của kiểm thử?",
		"right": "Liên phương thức và liên lớp"
	},
	{
		"question": "Trong loại toán tử đột biến tích hợp IREM, biểu thức trong mỗi câu lệnh trả về trong mỗi phương thức được sửa đổi bằng cách áp dụng toán tử nào?",
		"right": "UOI, AOR"
	},
	{
		"question": "Các vị dụ phản chứng là các đường dẫn qua FSM có thể được sử dụng làm các {{ca kiểm thử}}.",
		"right": null
	},
	{
		"question": "Để loại bỏ đột biến, chúng ta cần có {{trình tự các trạng thái}} từ máy hữu hạn trạng thái.",
		"right": null
	},
	{
		"question": "Mô tả trạng thái hữu hạn (Finite State) có thể nắm bắt {{hành vi của hệ thống || system behavior}} ở mức độ rất cao - thích hợp để giao tiếp với người dùng cuối.",
		"right": null
	},
	{
		"question": "Mô tả trạng thái hữu hạn có thể nắm bắt {{hành vi của hệ thống}} ở mức rất cao, thích hợp để giao tiếp với người dùng cuối.",
		"right": null
	},
	{
		"question": "Công cuộc tìm kiếm một ca kiểm thử để diệt đột biến máy trạng thái hữu hạn trong SVM có thể được tự động biểu thị thông qua cái gì?",
		"right": "Kiểm duyệt mô hình (model checker)."
	},
	{
		"question": "Một cơ chế trừu tượng sử dụng để cài đặt che dấu {{thông tin}} nó là một kỹ thuật thiết kế với mong muốn bảo vệ một số phần của thiết kế khỏi các phần của quá trình thực thi.",
		"right": null
	},
	{
		"question": "Trong việc chính thức hóa FSM, các trạng thái được {{định nghĩa ngầm}} bằng cách khai báo các biến có phạm vi giới hạn.",
		"right": null
	},
	{
		"question": "Trong việc chính thức hóa FSM, không gian trạng thái là {{tích Descartes}} của các phạm vi của các biến.",
		"right": null
	},
	{
		"question": "Trong việc chính thức hóa FSM, quá trình chuyển đổi được xác định bởi các {{quy tắc}} đặc trưng cho nguồn và đích của mỗi quá trình chuyển đổi.",
		"right": null
	},
	{
		"question": "Trong việc chính thức hóa FSM, trạng thái ban đầu được xác định bằng cách {{giới hạn phạm vi}} của một số hoặc tất cả các biến.",
		"right": null
	},
	{
		"question": "Đâu không phải là một ràng buộc của XML?",
		"right": "medianLength"
	},
	{
		"question": "Các tin XML được sử dụng như {{các ca kiểm thử}}.",
		"right": null
	},
	{
		"question": "Câu nào sau đây là sai?",
		"right": "Không gian đầu vào là giá trị nhỏ nhất và giá trị lớn nhất có thể đưa vào chương trình."
	},
	{
		"question": "Có thể sinh ra các ca kiểm thử dưới dạng tin XML (XML message) bằng cách lấy xâu (string) từ {{văn phạm||grammar}}.",
		"right": null
	},
	{
		"question": "Đâu không là phép toán đột biến?",
		"right": "Gây đột biến các dẫn xuất (Mutate Production)."
	},
	{
		"question": "Đâu không phải là phương pháp dựa trên ngữ pháp để mô tả không gian đầu vào?",
		"right": "Sử dụng máy hữu hạn trạng thái."
	},
	{
		"question": "Đâu là ràng buộc không biên của XML?",
		"right": "fractionDigits"
	},
	{
		"question": "Để miêu tả các miền đầu vào thì ta KHÔNG dùng tiêu chí dựa trên cú pháp nào sau đây?",
		"right": "Chuỗi nền (Ground Strings)."
	},
	{
		"question": "Điều nào sau đây là KHÔNG ĐÚNG khi nói về các bài kiểm thử hợp lệ (Valid Tests)?",
		"right": "Gây đột biến tập ngữ pháp theo những cách cấu trúc."
	},
	{
		"question": "Hầu hết các không gian đầu vào có thể được mô tả dưới dạng {{cú pháp}}.",
		"right": null
	},
	{
		"question": "Khi sử dụng tập ngữ pháp để thiết kế ca kiểm thử. Các tập ngữ pháp bị đột biến được sử dụng để tạo ra ___?",
		"right": "Thông báo XML (XML messages)."
	},
	{
		"question": "Không gian đầu vào không thể được diễn đạt bởi cách nào sau đây:",
		"right": "Văn bản"
	},
	{
		"question": "MNFP là tên viết tắt của tiêu chí {{Multiple Near False Point}}.",
		"right": null
	},
	{
		"question": "Phần mềm không nên làm gì với các dữ liệu đầu vào không hợp lệ?",
		"right": "Sử dụng dữ liệu như bình thường."
	},
	{
		"question": "Ràng buộc nào không phải là ràng buộc biên của XML?",
		"right": "enumeration"
	},
	{
		"question": "Trong các phần mềm, XML được ghép nối rất lỏng lẻo (Loosely Coupled). Đâu không là một trong những tiêu chí chỉ ra sự lỏng lẻo ấy?",
		"right": "Việc chia sẻ dữ liệu phụ thuộc vào kiểu dữ liệu."
	},
	{
		"question": "Trong đột biến XML các chương trình ít có khả năng kiểm tra tất cả tất cả {{các khía cạnh }} của schemas.",
		"right": null
	},
	{
		"question": "Trước khi bắt đầu xử lý đầu vào, các chương trình được viết tốt sẽ kiểm tra xem {{đầu vào có hợp lệ}}.",
		"right": null
	},
	{
		"question": "Đâu không phải là một cách dựa trên cú pháp để mô tả không gian đầu vào?",
		"right": "Cú pháp DTDs"
	},
	{
		"question": "Đâu không phải là một miền đầu vào khi áp dụng văn phạm không gian đầu vào trong kiểm thử?",
		"right": "Miền đầu vào (Input domain)."
	},
	{
		"question": "Khi thiết kế các ca kiểm thử, ngữ pháp nên được sử dụng để làm gì?",
		"right": "Tạo dữ liệu hợp lệ và không hợp lệ."
	},
	{
		"question": "Tất cả các thông điệp XML đều cần phải có điều nào sau đây?",
		"right": "Chính xác (well-formed)"
	},
	{
		"question": "___ có định nghĩa là mỗi ký hiệu đầu cuối trong sản xuất được thay thế bằng các ký hiệu đầu cuối khác.",
		"right": "Thay thế thiết bị đầu cuối."
	},
	{
		"question": "{{Nạp chồng}} phương thức cho phép một phương thức trong lớp con có cùng tên, các đối số và kiểu kết quả giống như một phương thức trong lớp cha của nó.",
		"right": null
	},
	{
		"question": "Đâu là ràng buộc biên của XML?",
		"right": "Không có đáp án đúng."
	},
	{
		"question": "Đâu là ràng buộc không biên của XML?",
		"right": "nillable"
	},
	{
		"question": "Lược đồ XML (XML schema) có thể đột biến được không?",
		"right": "Có"
	},
	{
		"question": "Phạm vi sản phẩm (PDC) yêu cầu hai kiểm thử là: {{có}} ISBN và {{không có}} ISBN.",
		"right": null
	},
	{
		"question": "Ràng buộc XML nào sau đây thuộc loại ràng buộc có biên?",
		"right": "Ràng buộc maxOccurs."
	},
	{
		"question": "Ràng buộc XML nào sau đây thuộc loại ràng buộc không biên?",
		"right": "Ràng buộc enumeration."
	},
	{
		"question": "Số cách phương pháp tiếp cận cho việc mô hình hóa miền đầu vào?",
		"right": 2
	}
]
